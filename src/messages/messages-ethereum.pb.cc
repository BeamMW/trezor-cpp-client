// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-ethereum.proto

#include "messages-ethereum.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_messages_2dcommon_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2dcommon_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_HDNodeType;
}  // namespace protobuf_messages_2dcommon_2eproto
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {
class EthereumGetPublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumGetPublicKey>
      _instance;
} _EthereumGetPublicKey_default_instance_;
class EthereumPublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumPublicKey>
      _instance;
} _EthereumPublicKey_default_instance_;
class EthereumGetAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumGetAddress>
      _instance;
} _EthereumGetAddress_default_instance_;
class EthereumAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumAddress>
      _instance;
} _EthereumAddress_default_instance_;
class EthereumSignTxDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumSignTx>
      _instance;
} _EthereumSignTx_default_instance_;
class EthereumTxRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxRequest>
      _instance;
} _EthereumTxRequest_default_instance_;
class EthereumTxAckDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxAck>
      _instance;
} _EthereumTxAck_default_instance_;
class EthereumSignMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumSignMessage>
      _instance;
} _EthereumSignMessage_default_instance_;
class EthereumMessageSignatureDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumMessageSignature>
      _instance;
} _EthereumMessageSignature_default_instance_;
class EthereumVerifyMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumVerifyMessage>
      _instance;
} _EthereumVerifyMessage_default_instance_;
}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace protobuf_messages_2dethereum_2eproto {
static void InitDefaultsEthereumGetPublicKey() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumGetPublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumGetPublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumGetPublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumGetPublicKey =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumGetPublicKey}, {}};

static void InitDefaultsEthereumPublicKey() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumPublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumPublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_EthereumPublicKey =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsEthereumPublicKey}, {
      &protobuf_messages_2dcommon_2eproto::scc_info_HDNodeType.base,}};

static void InitDefaultsEthereumGetAddress() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumGetAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumGetAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumGetAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumGetAddress =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumGetAddress}, {}};

static void InitDefaultsEthereumAddress() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumAddress =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumAddress}, {}};

static void InitDefaultsEthereumSignTx() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumSignTx_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumSignTx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumSignTx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumSignTx =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumSignTx}, {}};

static void InitDefaultsEthereumTxRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumTxRequest_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumTxRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumTxRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumTxRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumTxRequest}, {}};

static void InitDefaultsEthereumTxAck() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumTxAck_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumTxAck();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumTxAck::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumTxAck =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumTxAck}, {}};

static void InitDefaultsEthereumSignMessage() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumSignMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumSignMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumSignMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumSignMessage =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumSignMessage}, {}};

static void InitDefaultsEthereumMessageSignature() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumMessageSignature_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumMessageSignature();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumMessageSignature::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumMessageSignature =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumMessageSignature}, {}};

static void InitDefaultsEthereumVerifyMessage() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumVerifyMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumVerifyMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumVerifyMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumVerifyMessage =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumVerifyMessage}, {}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumGetPublicKey.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumPublicKey.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumGetAddress.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumAddress.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumSignTx.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumTxRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumTxAck.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumSignMessage.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumMessageSignature.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumVerifyMessage.base);
}

::google::protobuf::Metadata file_level_metadata[10];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, show_display_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, node_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, xpub_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, show_display_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, address_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, nonce_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, gas_price_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, gas_limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, to_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, value_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, data_initial_chunk_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, data_length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, chain_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, tx_type_),
  ~0u,
  0,
  1,
  2,
  5,
  3,
  4,
  6,
  7,
  8,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, data_length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_v_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_r_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_s_),
  2,
  3,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, data_chunk_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, message_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, signature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, address_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, signature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, address_),
  0,
  1,
  2,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::hw::trezor::messages::ethereum::EthereumGetPublicKey)},
  { 9, 16, sizeof(::hw::trezor::messages::ethereum::EthereumPublicKey)},
  { 18, 25, sizeof(::hw::trezor::messages::ethereum::EthereumGetAddress)},
  { 27, 33, sizeof(::hw::trezor::messages::ethereum::EthereumAddress)},
  { 34, 49, sizeof(::hw::trezor::messages::ethereum::EthereumSignTx)},
  { 59, 68, sizeof(::hw::trezor::messages::ethereum::EthereumTxRequest)},
  { 72, 78, sizeof(::hw::trezor::messages::ethereum::EthereumTxAck)},
  { 79, 86, sizeof(::hw::trezor::messages::ethereum::EthereumSignMessage)},
  { 88, 95, sizeof(::hw::trezor::messages::ethereum::EthereumMessageSignature)},
  { 97, 105, sizeof(::hw::trezor::messages::ethereum::EthereumVerifyMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumGetPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumGetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumSignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumTxRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumTxAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumSignMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumMessageSignature_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumVerifyMessage_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "messages-ethereum.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 10);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\027messages-ethereum.proto\022\033hw.trezor.mes"
      "sages.ethereum\032\025messages-common.proto\"\?\n"
      "\024EthereumGetPublicKey\022\021\n\taddress_n\030\001 \003(\r"
      "\022\024\n\014show_display\030\002 \001(\010\"V\n\021EthereumPublic"
      "Key\0223\n\004node\030\001 \001(\0132%.hw.trezor.messages.c"
      "ommon.HDNodeType\022\014\n\004xpub\030\002 \001(\t\"=\n\022Ethere"
      "umGetAddress\022\021\n\taddress_n\030\001 \003(\r\022\024\n\014show_"
      "display\030\002 \001(\010\"\"\n\017EthereumAddress\022\017\n\007addr"
      "ess\030\002 \001(\t\"\307\001\n\016EthereumSignTx\022\021\n\taddress_"
      "n\030\001 \003(\r\022\r\n\005nonce\030\002 \001(\014\022\021\n\tgas_price\030\003 \001("
      "\014\022\021\n\tgas_limit\030\004 \001(\014\022\n\n\002to\030\013 \001(\t\022\r\n\005valu"
      "e\030\006 \001(\014\022\032\n\022data_initial_chunk\030\007 \001(\014\022\023\n\013d"
      "ata_length\030\010 \001(\r\022\020\n\010chain_id\030\t \001(\r\022\017\n\007tx"
      "_type\030\n \001(\r\"g\n\021EthereumTxRequest\022\023\n\013data"
      "_length\030\001 \001(\r\022\023\n\013signature_v\030\002 \001(\r\022\023\n\013si"
      "gnature_r\030\003 \001(\014\022\023\n\013signature_s\030\004 \001(\014\"#\n\r"
      "EthereumTxAck\022\022\n\ndata_chunk\030\001 \001(\014\"9\n\023Eth"
      "ereumSignMessage\022\021\n\taddress_n\030\001 \003(\r\022\017\n\007m"
      "essage\030\002 \001(\014\">\n\030EthereumMessageSignature"
      "\022\021\n\tsignature\030\002 \001(\014\022\017\n\007address\030\003 \001(\t\"L\n\025"
      "EthereumVerifyMessage\022\021\n\tsignature\030\002 \001(\014"
      "\022\017\n\007message\030\003 \001(\014\022\017\n\007address\030\004 \001(\tB<\n#co"
      "m.satoshilabs.trezor.lib.protobufB\025Trezo"
      "rMessageEthereum"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 936);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages-ethereum.proto", &protobuf_RegisterTypes);
  ::protobuf_messages_2dcommon_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_messages_2dethereum_2eproto
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {

// ===================================================================

void EthereumGetPublicKey::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumGetPublicKey::kAddressNFieldNumber;
const int EthereumGetPublicKey::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumGetPublicKey::EthereumGetPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumGetPublicKey.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}
EthereumGetPublicKey::EthereumGetPublicKey(const EthereumGetPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}

void EthereumGetPublicKey::SharedCtor() {
  show_display_ = false;
}

EthereumGetPublicKey::~EthereumGetPublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  SharedDtor();
}

void EthereumGetPublicKey::SharedDtor() {
}

void EthereumGetPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumGetPublicKey::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumGetPublicKey& EthereumGetPublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumGetPublicKey.base);
  return *internal_default_instance();
}


void EthereumGetPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumGetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_show_display();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return false;
#undef DO_
}

void EthereumGetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}

::google::protobuf::uint8* EthereumGetPublicKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return target;
}

size_t EthereumGetPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bool show_display = 2;
  if (has_show_display()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumGetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumGetPublicKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumGetPublicKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumGetPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumGetPublicKey)
    MergeFrom(*source);
  }
}

void EthereumGetPublicKey::MergeFrom(const EthereumGetPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_show_display()) {
    set_show_display(from.show_display());
  }
}

void EthereumGetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumGetPublicKey::CopyFrom(const EthereumGetPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumGetPublicKey::IsInitialized() const {
  return true;
}

void EthereumGetPublicKey::Swap(EthereumGetPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumGetPublicKey::InternalSwap(EthereumGetPublicKey* other) {
  using std::swap;
  address_n_.InternalSwap(&other->address_n_);
  swap(show_display_, other->show_display_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumGetPublicKey::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumPublicKey::InitAsDefaultInstance() {
  ::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_._instance.get_mutable()->node_ = const_cast< ::hw::trezor::messages::common::HDNodeType*>(
      ::hw::trezor::messages::common::HDNodeType::internal_default_instance());
}
void EthereumPublicKey::clear_node() {
  if (node_ != NULL) node_->Clear();
  clear_has_node();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumPublicKey::kNodeFieldNumber;
const int EthereumPublicKey::kXpubFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumPublicKey::EthereumPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumPublicKey.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumPublicKey)
}
EthereumPublicKey::EthereumPublicKey(const EthereumPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_xpub()) {
    xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
  }
  if (from.has_node()) {
    node_ = new ::hw::trezor::messages::common::HDNodeType(*from.node_);
  } else {
    node_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumPublicKey)
}

void EthereumPublicKey::SharedCtor() {
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_ = NULL;
}

EthereumPublicKey::~EthereumPublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumPublicKey)
  SharedDtor();
}

void EthereumPublicKey::SharedDtor() {
  xpub_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete node_;
}

void EthereumPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumPublicKey::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumPublicKey& EthereumPublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumPublicKey.base);
  return *internal_default_instance();
}


void EthereumPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      xpub_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(node_ != NULL);
      node_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xpub().data(), static_cast<int>(this->xpub().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumPublicKey)
  return false;
#undef DO_
}

void EthereumPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_node(), output);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->xpub(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumPublicKey)
}

::google::protobuf::uint8* EthereumPublicKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_node(), deterministic, target);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumPublicKey)
  return target;
}

size_t EthereumPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string xpub = 2;
    if (has_xpub()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->xpub());
    }

    // optional .hw.trezor.messages.common.HDNodeType node = 1;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *node_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumPublicKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumPublicKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumPublicKey)
    MergeFrom(*source);
  }
}

void EthereumPublicKey::MergeFrom(const EthereumPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_xpub();
      xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_node()->::hw::trezor::messages::common::HDNodeType::MergeFrom(from.node());
    }
  }
}

void EthereumPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumPublicKey::CopyFrom(const EthereumPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumPublicKey::IsInitialized() const {
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void EthereumPublicKey::Swap(EthereumPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumPublicKey::InternalSwap(EthereumPublicKey* other) {
  using std::swap;
  xpub_.Swap(&other->xpub_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(node_, other->node_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumPublicKey::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumGetAddress::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumGetAddress::kAddressNFieldNumber;
const int EthereumGetAddress::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumGetAddress::EthereumGetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumGetAddress.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumGetAddress)
}
EthereumGetAddress::EthereumGetAddress(const EthereumGetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumGetAddress)
}

void EthereumGetAddress::SharedCtor() {
  show_display_ = false;
}

EthereumGetAddress::~EthereumGetAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumGetAddress)
  SharedDtor();
}

void EthereumGetAddress::SharedDtor() {
}

void EthereumGetAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumGetAddress::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumGetAddress& EthereumGetAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumGetAddress.base);
  return *internal_default_instance();
}


void EthereumGetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumGetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_show_display();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumGetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumGetAddress)
  return false;
#undef DO_
}

void EthereumGetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumGetAddress)
}

::google::protobuf::uint8* EthereumGetAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumGetAddress)
  return target;
}

size_t EthereumGetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bool show_display = 2;
  if (has_show_display()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumGetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumGetAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumGetAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumGetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumGetAddress)
    MergeFrom(*source);
  }
}

void EthereumGetAddress::MergeFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_show_display()) {
    set_show_display(from.show_display());
  }
}

void EthereumGetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumGetAddress::CopyFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumGetAddress::IsInitialized() const {
  return true;
}

void EthereumGetAddress::Swap(EthereumGetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumGetAddress::InternalSwap(EthereumGetAddress* other) {
  using std::swap;
  address_n_.InternalSwap(&other->address_n_);
  swap(show_display_, other->show_display_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumGetAddress::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumAddress::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumAddress::EthereumAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumAddress.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumAddress)
}
EthereumAddress::EthereumAddress(const EthereumAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumAddress)
}

void EthereumAddress::SharedCtor() {
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumAddress::~EthereumAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumAddress)
  SharedDtor();
}

void EthereumAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumAddress::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumAddress& EthereumAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumAddress.base);
  return *internal_default_instance();
}


void EthereumAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumAddress.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumAddress)
  return false;
#undef DO_
}

void EthereumAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumAddress)
}

::google::protobuf::uint8* EthereumAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumAddress)
  return target;
}

size_t EthereumAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional string address = 2;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumAddress)
    MergeFrom(*source);
  }
}

void EthereumAddress::MergeFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    set_has_address();
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void EthereumAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumAddress::CopyFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumAddress::IsInitialized() const {
  return true;
}

void EthereumAddress::Swap(EthereumAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumAddress::InternalSwap(EthereumAddress* other) {
  using std::swap;
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumAddress::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumSignTx::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumSignTx::kAddressNFieldNumber;
const int EthereumSignTx::kNonceFieldNumber;
const int EthereumSignTx::kGasPriceFieldNumber;
const int EthereumSignTx::kGasLimitFieldNumber;
const int EthereumSignTx::kToFieldNumber;
const int EthereumSignTx::kValueFieldNumber;
const int EthereumSignTx::kDataInitialChunkFieldNumber;
const int EthereumSignTx::kDataLengthFieldNumber;
const int EthereumSignTx::kChainIdFieldNumber;
const int EthereumSignTx::kTxTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumSignTx::EthereumSignTx()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumSignTx.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumSignTx)
}
EthereumSignTx::EthereumSignTx(const EthereumSignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_price()) {
    gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
  }
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_limit()) {
    gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_initial_chunk()) {
    data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
  }
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_to()) {
    to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&tx_type_) -
    reinterpret_cast<char*>(&data_length_)) + sizeof(tx_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumSignTx)
}

void EthereumSignTx::SharedCtor() {
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tx_type_) -
      reinterpret_cast<char*>(&data_length_)) + sizeof(tx_type_));
}

EthereumSignTx::~EthereumSignTx() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumSignTx)
  SharedDtor();
}

void EthereumSignTx::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumSignTx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumSignTx::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumSignTx& EthereumSignTx::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumSignTx.base);
  return *internal_default_instance();
}


void EthereumSignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      nonce_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      gas_price_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      gas_limit_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      value_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      data_initial_chunk_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      to_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 192u) {
    ::memset(&data_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chain_id_) -
        reinterpret_cast<char*>(&data_length_)) + sizeof(chain_id_));
  }
  tx_type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumSignTx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_price = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_price()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes value = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data_initial_chunk = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_initial_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 data_length = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_data_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 chain_id = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_chain_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chain_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tx_type = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_tx_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string to = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->to().data(), static_cast<int>(this->to().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumSignTx.to");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumSignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumSignTx)
  return false;
#undef DO_
}

void EthereumSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->gas_price(), output);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->gas_limit(), output);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->value(), output);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->data_initial_chunk(), output);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->data_length(), output);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->chain_id(), output);
  }

  // optional uint32 tx_type = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->tx_type(), output);
  }

  // optional string to = 11;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->to().data(), static_cast<int>(this->to().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumSignTx.to");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->to(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumSignTx)
}

::google::protobuf::uint8* EthereumSignTx::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->gas_price(), target);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->gas_limit(), target);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->value(), target);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->data_initial_chunk(), target);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->data_length(), target);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->chain_id(), target);
  }

  // optional uint32 tx_type = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->tx_type(), target);
  }

  // optional string to = 11;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->to().data(), static_cast<int>(this->to().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumSignTx.to");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->to(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumSignTx)
  return target;
}

size_t EthereumSignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumSignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional bytes gas_price = 3;
    if (has_gas_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_price());
    }

    // optional bytes gas_limit = 4;
    if (has_gas_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_limit());
    }

    // optional bytes value = 6;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

    // optional bytes data_initial_chunk = 7;
    if (has_data_initial_chunk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data_initial_chunk());
    }

    // optional string to = 11;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to());
    }

    // optional uint32 data_length = 8;
    if (has_data_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 chain_id = 9;
    if (has_chain_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chain_id());
    }

  }
  // optional uint32 tx_type = 10;
  if (has_tx_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tx_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumSignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumSignTx* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumSignTx>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumSignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumSignTx)
    MergeFrom(*source);
  }
}

void EthereumSignTx::MergeFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nonce();
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_gas_price();
      gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_gas_limit();
      gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_data_initial_chunk();
      data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
    }
    if (cached_has_bits & 0x00000020u) {
      set_has_to();
      to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
    }
    if (cached_has_bits & 0x00000040u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      chain_id_ = from.chain_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_tx_type(from.tx_type());
  }
}

void EthereumSignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumSignTx::CopyFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumSignTx::IsInitialized() const {
  return true;
}

void EthereumSignTx::Swap(EthereumSignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumSignTx::InternalSwap(EthereumSignTx* other) {
  using std::swap;
  address_n_.InternalSwap(&other->address_n_);
  nonce_.Swap(&other->nonce_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gas_price_.Swap(&other->gas_price_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gas_limit_.Swap(&other->gas_limit_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  value_.Swap(&other->value_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  data_initial_chunk_.Swap(&other->data_initial_chunk_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  to_.Swap(&other->to_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_length_, other->data_length_);
  swap(chain_id_, other->chain_id_);
  swap(tx_type_, other->tx_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumSignTx::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumTxRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxRequest::kDataLengthFieldNumber;
const int EthereumTxRequest::kSignatureVFieldNumber;
const int EthereumTxRequest::kSignatureRFieldNumber;
const int EthereumTxRequest::kSignatureSFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxRequest::EthereumTxRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumTxRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumTxRequest)
}
EthereumTxRequest::EthereumTxRequest(const EthereumTxRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_r()) {
    signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
  }
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_s()) {
    signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&signature_v_) -
    reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumTxRequest)
}

void EthereumTxRequest::SharedCtor() {
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&signature_v_) -
      reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
}

EthereumTxRequest::~EthereumTxRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumTxRequest)
  SharedDtor();
}

void EthereumTxRequest::SharedDtor() {
  signature_r_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumTxRequest::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumTxRequest& EthereumTxRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumTxRequest.base);
  return *internal_default_instance();
}


void EthereumTxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      signature_r_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_s_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 12u) {
    ::memset(&data_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&signature_v_) -
        reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumTxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 data_length = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_data_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 signature_v = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_signature_v();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_v_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_r = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_r()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_s = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_s()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumTxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumTxRequest)
  return false;
#undef DO_
}

void EthereumTxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->data_length(), output);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->signature_v(), output);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature_r(), output);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->signature_s(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumTxRequest)
}

::google::protobuf::uint8* EthereumTxRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->data_length(), target);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->signature_v(), target);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature_r(), target);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature_s(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumTxRequest)
  return target;
}

size_t EthereumTxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes signature_r = 3;
    if (has_signature_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_r());
    }

    // optional bytes signature_s = 4;
    if (has_signature_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_s());
    }

    // optional uint32 data_length = 1;
    if (has_data_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 signature_v = 2;
    if (has_signature_v()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_v());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumTxRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumTxRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumTxRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumTxRequest)
    MergeFrom(*source);
  }
}

void EthereumTxRequest::MergeFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_signature_r();
      signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_signature_s();
      signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
    }
    if (cached_has_bits & 0x00000004u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000008u) {
      signature_v_ = from.signature_v_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EthereumTxRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxRequest::CopyFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxRequest::IsInitialized() const {
  return true;
}

void EthereumTxRequest::Swap(EthereumTxRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxRequest::InternalSwap(EthereumTxRequest* other) {
  using std::swap;
  signature_r_.Swap(&other->signature_r_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_s_.Swap(&other->signature_s_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_length_, other->data_length_);
  swap(signature_v_, other->signature_v_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumTxRequest::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumTxAck::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxAck::kDataChunkFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxAck::EthereumTxAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumTxAck.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumTxAck)
}
EthereumTxAck::EthereumTxAck(const EthereumTxAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_chunk()) {
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumTxAck)
}

void EthereumTxAck::SharedCtor() {
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumTxAck::~EthereumTxAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumTxAck)
  SharedDtor();
}

void EthereumTxAck::SharedDtor() {
  data_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumTxAck::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumTxAck& EthereumTxAck::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumTxAck.base);
  return *internal_default_instance();
}


void EthereumTxAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_chunk_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumTxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumTxAck)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data_chunk = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumTxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumTxAck)
  return false;
#undef DO_
}

void EthereumTxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data_chunk(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumTxAck)
}

::google::protobuf::uint8* EthereumTxAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data_chunk(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumTxAck)
  return target;
}

size_t EthereumTxAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumTxAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional bytes data_chunk = 1;
  if (has_data_chunk()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data_chunk());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumTxAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumTxAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumTxAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumTxAck)
    MergeFrom(*source);
  }
}

void EthereumTxAck::MergeFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_data_chunk()) {
    set_has_data_chunk();
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
}

void EthereumTxAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxAck::CopyFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxAck::IsInitialized() const {
  return true;
}

void EthereumTxAck::Swap(EthereumTxAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxAck::InternalSwap(EthereumTxAck* other) {
  using std::swap;
  data_chunk_.Swap(&other->data_chunk_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumTxAck::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumSignMessage::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumSignMessage::kAddressNFieldNumber;
const int EthereumSignMessage::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumSignMessage::EthereumSignMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumSignMessage.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumSignMessage)
}
EthereumSignMessage::EthereumSignMessage(const EthereumSignMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumSignMessage)
}

void EthereumSignMessage::SharedCtor() {
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumSignMessage::~EthereumSignMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumSignMessage)
  SharedDtor();
}

void EthereumSignMessage::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumSignMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumSignMessage::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumSignMessage& EthereumSignMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumSignMessage.base);
  return *internal_default_instance();
}


void EthereumSignMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumSignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumSignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumSignMessage)
  return false;
#undef DO_
}

void EthereumSignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumSignMessage)
}

::google::protobuf::uint8* EthereumSignMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumSignMessage)
  return target;
}

size_t EthereumSignMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bytes message = 2;
  if (has_message()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumSignMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumSignMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumSignMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumSignMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumSignMessage)
    MergeFrom(*source);
  }
}

void EthereumSignMessage::MergeFrom(const EthereumSignMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_message()) {
    set_has_message();
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void EthereumSignMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumSignMessage::CopyFrom(const EthereumSignMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumSignMessage::IsInitialized() const {
  return true;
}

void EthereumSignMessage::Swap(EthereumSignMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumSignMessage::InternalSwap(EthereumSignMessage* other) {
  using std::swap;
  address_n_.InternalSwap(&other->address_n_);
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumSignMessage::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumMessageSignature::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumMessageSignature::kSignatureFieldNumber;
const int EthereumMessageSignature::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumMessageSignature::EthereumMessageSignature()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumMessageSignature.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
}
EthereumMessageSignature::EthereumMessageSignature(const EthereumMessageSignature& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
}

void EthereumMessageSignature::SharedCtor() {
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumMessageSignature::~EthereumMessageSignature() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
  SharedDtor();
}

void EthereumMessageSignature::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumMessageSignature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumMessageSignature::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumMessageSignature& EthereumMessageSignature::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumMessageSignature.base);
  return *internal_default_instance();
}


void EthereumMessageSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumMessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return false;
#undef DO_
}

void EthereumMessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumMessageSignature)
}

::google::protobuf::uint8* EthereumMessageSignature::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return target;
}

size_t EthereumMessageSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional string address = 3;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumMessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumMessageSignature* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumMessageSignature>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumMessageSignature)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumMessageSignature)
    MergeFrom(*source);
  }
}

void EthereumMessageSignature::MergeFrom(const EthereumMessageSignature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
  }
}

void EthereumMessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumMessageSignature::CopyFrom(const EthereumMessageSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumMessageSignature::IsInitialized() const {
  return true;
}

void EthereumMessageSignature::Swap(EthereumMessageSignature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumMessageSignature::InternalSwap(EthereumMessageSignature* other) {
  using std::swap;
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumMessageSignature::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EthereumVerifyMessage::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumVerifyMessage::kSignatureFieldNumber;
const int EthereumVerifyMessage::kMessageFieldNumber;
const int EthereumVerifyMessage::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumVerifyMessage::EthereumVerifyMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_messages_2dethereum_2eproto::scc_info_EthereumVerifyMessage.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}
EthereumVerifyMessage::EthereumVerifyMessage(const EthereumVerifyMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}

void EthereumVerifyMessage::SharedCtor() {
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumVerifyMessage::~EthereumVerifyMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  SharedDtor();
}

void EthereumVerifyMessage::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumVerifyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EthereumVerifyMessage::descriptor() {
  ::protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumVerifyMessage& EthereumVerifyMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_messages_2dethereum_2eproto::scc_info_EthereumVerifyMessage.base);
  return *internal_default_instance();
}


void EthereumVerifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumVerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return false;
#undef DO_
}

void EthereumVerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional string address = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}

::google::protobuf::uint8* EthereumVerifyMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional string address = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return target;
}

size_t EthereumVerifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string address = 4;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumVerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumVerifyMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumVerifyMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumVerifyMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumVerifyMessage)
    MergeFrom(*source);
  }
}

void EthereumVerifyMessage::MergeFrom(const EthereumVerifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
  }
}

void EthereumVerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumVerifyMessage::CopyFrom(const EthereumVerifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumVerifyMessage::IsInitialized() const {
  return true;
}

void EthereumVerifyMessage::Swap(EthereumVerifyMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumVerifyMessage::InternalSwap(EthereumVerifyMessage* other) {
  using std::swap;
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EthereumVerifyMessage::GetMetadata() const {
  protobuf_messages_2dethereum_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_messages_2dethereum_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumGetPublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumGetPublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumGetPublicKey >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumPublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumPublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumPublicKey >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumGetAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumGetAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumGetAddress >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumAddress >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumSignTx* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumSignTx >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumSignTx >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumTxRequest* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumTxRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumTxRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumTxAck* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumTxAck >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumTxAck >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumSignMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumSignMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumSignMessage >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumMessageSignature* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumMessageSignature >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumMessageSignature >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::hw::trezor::messages::ethereum::EthereumVerifyMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumVerifyMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumVerifyMessage >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
