// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-nem.proto

#ifndef PROTOBUF_INCLUDED_messages_2dnem_2eproto
#define PROTOBUF_INCLUDED_messages_2dnem_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2dnem_2eproto 

namespace protobuf_messages_2dnem_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2dnem_2eproto
namespace hw {
namespace trezor {
namespace messages {
namespace nem {
class NEMAddress;
class NEMAddressDefaultTypeInternal;
extern NEMAddressDefaultTypeInternal _NEMAddress_default_instance_;
class NEMDecryptMessage;
class NEMDecryptMessageDefaultTypeInternal;
extern NEMDecryptMessageDefaultTypeInternal _NEMDecryptMessage_default_instance_;
class NEMDecryptedMessage;
class NEMDecryptedMessageDefaultTypeInternal;
extern NEMDecryptedMessageDefaultTypeInternal _NEMDecryptedMessage_default_instance_;
class NEMGetAddress;
class NEMGetAddressDefaultTypeInternal;
extern NEMGetAddressDefaultTypeInternal _NEMGetAddress_default_instance_;
class NEMSignTx;
class NEMSignTxDefaultTypeInternal;
extern NEMSignTxDefaultTypeInternal _NEMSignTx_default_instance_;
class NEMSignTx_NEMAggregateModification;
class NEMSignTx_NEMAggregateModificationDefaultTypeInternal;
extern NEMSignTx_NEMAggregateModificationDefaultTypeInternal _NEMSignTx_NEMAggregateModification_default_instance_;
class NEMSignTx_NEMAggregateModification_NEMCosignatoryModification;
class NEMSignTx_NEMAggregateModification_NEMCosignatoryModificationDefaultTypeInternal;
extern NEMSignTx_NEMAggregateModification_NEMCosignatoryModificationDefaultTypeInternal _NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_default_instance_;
class NEMSignTx_NEMImportanceTransfer;
class NEMSignTx_NEMImportanceTransferDefaultTypeInternal;
extern NEMSignTx_NEMImportanceTransferDefaultTypeInternal _NEMSignTx_NEMImportanceTransfer_default_instance_;
class NEMSignTx_NEMMosaicCreation;
class NEMSignTx_NEMMosaicCreationDefaultTypeInternal;
extern NEMSignTx_NEMMosaicCreationDefaultTypeInternal _NEMSignTx_NEMMosaicCreation_default_instance_;
class NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition;
class NEMSignTx_NEMMosaicCreation_NEMMosaicDefinitionDefaultTypeInternal;
extern NEMSignTx_NEMMosaicCreation_NEMMosaicDefinitionDefaultTypeInternal _NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_;
class NEMSignTx_NEMMosaicSupplyChange;
class NEMSignTx_NEMMosaicSupplyChangeDefaultTypeInternal;
extern NEMSignTx_NEMMosaicSupplyChangeDefaultTypeInternal _NEMSignTx_NEMMosaicSupplyChange_default_instance_;
class NEMSignTx_NEMProvisionNamespace;
class NEMSignTx_NEMProvisionNamespaceDefaultTypeInternal;
extern NEMSignTx_NEMProvisionNamespaceDefaultTypeInternal _NEMSignTx_NEMProvisionNamespace_default_instance_;
class NEMSignTx_NEMTransactionCommon;
class NEMSignTx_NEMTransactionCommonDefaultTypeInternal;
extern NEMSignTx_NEMTransactionCommonDefaultTypeInternal _NEMSignTx_NEMTransactionCommon_default_instance_;
class NEMSignTx_NEMTransfer;
class NEMSignTx_NEMTransferDefaultTypeInternal;
extern NEMSignTx_NEMTransferDefaultTypeInternal _NEMSignTx_NEMTransfer_default_instance_;
class NEMSignTx_NEMTransfer_NEMMosaic;
class NEMSignTx_NEMTransfer_NEMMosaicDefaultTypeInternal;
extern NEMSignTx_NEMTransfer_NEMMosaicDefaultTypeInternal _NEMSignTx_NEMTransfer_NEMMosaic_default_instance_;
class NEMSignedTx;
class NEMSignedTxDefaultTypeInternal;
extern NEMSignedTxDefaultTypeInternal _NEMSignedTx_default_instance_;
}  // namespace nem
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::nem::NEMAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMAddress>(Arena*);
template<> ::hw::trezor::messages::nem::NEMDecryptMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMDecryptMessage>(Arena*);
template<> ::hw::trezor::messages::nem::NEMDecryptedMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMDecryptedMessage>(Arena*);
template<> ::hw::trezor::messages::nem::NEMGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMGetAddress>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransfer>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic>(Arena*);
template<> ::hw::trezor::messages::nem::NEMSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignedTx>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace nem {

enum NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Absolute = 1,
  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Percentile = 2
};
bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(int value);
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_MIN = NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Absolute;
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_MAX = NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Percentile;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_ARRAYSIZE = NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_MAX + 1;

const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor();
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_Name(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy value) {
  return ::google::protobuf::internal::NameOfEnum(
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor(), value);
}
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_Parse(
    const ::std::string& name, NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy>(
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor(), name, value);
}
enum NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
  NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Increase = 1,
  NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Decrease = 2
};
bool NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(int value);
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_MIN = NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Increase;
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_MAX = NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Decrease;
const int NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_ARRAYSIZE = NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor();
inline const ::std::string& NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_Name(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor(), value);
}
inline bool NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_Parse(
    const ::std::string& name, NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType>(
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor(), name, value);
}
enum NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Add = 1,
  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Delete = 2
};
bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(int value);
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_MIN = NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Add;
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_MAX = NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Delete;
const int NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_ARRAYSIZE = NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor();
inline const ::std::string& NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_Name(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor(), value);
}
inline bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_Parse(
    const ::std::string& name, NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType>(
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor(), name, value);
}
enum NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
  NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Activate = 1,
  NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Deactivate = 2
};
bool NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(int value);
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_MIN = NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Activate;
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_MAX = NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Deactivate;
const int NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_ARRAYSIZE = NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor();
inline const ::std::string& NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_Name(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor(), value);
}
inline bool NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_Parse(
    const ::std::string& name, NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode>(
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor(), name, value);
}
// ===================================================================

class NEMGetAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMGetAddress) */ {
 public:
  NEMGetAddress();
  virtual ~NEMGetAddress();

  NEMGetAddress(const NEMGetAddress& from);

  inline NEMGetAddress& operator=(const NEMGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMGetAddress(NEMGetAddress&& from) noexcept
    : NEMGetAddress() {
    *this = ::std::move(from);
  }

  inline NEMGetAddress& operator=(NEMGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMGetAddress* internal_default_instance() {
    return reinterpret_cast<const NEMGetAddress*>(
               &_NEMGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(NEMGetAddress* other);
  friend void swap(NEMGetAddress& a, NEMGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMGetAddress* New() const final {
    return CreateMaybeMessage<NEMGetAddress>(NULL);
  }

  NEMGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMGetAddress& from);
  void MergeFrom(const NEMGetAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network = 2;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  ::google::protobuf::uint32 network() const;
  void set_network(::google::protobuf::uint32 value);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMGetAddress)
 private:
  void set_has_network();
  void clear_has_network();
  void set_has_show_display();
  void clear_has_show_display();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 network_;
  bool show_display_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMAddress) */ {
 public:
  NEMAddress();
  virtual ~NEMAddress();

  NEMAddress(const NEMAddress& from);

  inline NEMAddress& operator=(const NEMAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMAddress(NEMAddress&& from) noexcept
    : NEMAddress() {
    *this = ::std::move(from);
  }

  inline NEMAddress& operator=(NEMAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMAddress* internal_default_instance() {
    return reinterpret_cast<const NEMAddress*>(
               &_NEMAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NEMAddress* other);
  friend void swap(NEMAddress& a, NEMAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMAddress* New() const final {
    return CreateMaybeMessage<NEMAddress>(NULL);
  }

  NEMAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMAddress& from);
  void MergeFrom(const NEMAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMAddress)
 private:
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMTransactionCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon) */ {
 public:
  NEMSignTx_NEMTransactionCommon();
  virtual ~NEMSignTx_NEMTransactionCommon();

  NEMSignTx_NEMTransactionCommon(const NEMSignTx_NEMTransactionCommon& from);

  inline NEMSignTx_NEMTransactionCommon& operator=(const NEMSignTx_NEMTransactionCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMTransactionCommon(NEMSignTx_NEMTransactionCommon&& from) noexcept
    : NEMSignTx_NEMTransactionCommon() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMTransactionCommon& operator=(NEMSignTx_NEMTransactionCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMTransactionCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMTransactionCommon* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMTransactionCommon*>(
               &_NEMSignTx_NEMTransactionCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NEMSignTx_NEMTransactionCommon* other);
  friend void swap(NEMSignTx_NEMTransactionCommon& a, NEMSignTx_NEMTransactionCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMTransactionCommon* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransactionCommon>(NULL);
  }

  NEMSignTx_NEMTransactionCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransactionCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMTransactionCommon& from);
  void MergeFrom(const NEMSignTx_NEMTransactionCommon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMTransactionCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes signer = 6;
  bool has_signer() const;
  void clear_signer();
  static const int kSignerFieldNumber = 6;
  const ::std::string& signer() const;
  void set_signer(const ::std::string& value);
  #if LANG_CXX11
  void set_signer(::std::string&& value);
  #endif
  void set_signer(const char* value);
  void set_signer(const void* value, size_t size);
  ::std::string* mutable_signer();
  ::std::string* release_signer();
  void set_allocated_signer(::std::string* signer);

  // optional uint32 network = 2;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  ::google::protobuf::uint32 network() const;
  void set_network(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint64 fee = 4;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 4;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint32 deadline = 5;
  bool has_deadline() const;
  void clear_deadline();
  static const int kDeadlineFieldNumber = 5;
  ::google::protobuf::uint32 deadline() const;
  void set_deadline(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
 private:
  void set_has_network();
  void clear_has_network();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_fee();
  void clear_has_fee();
  void set_has_deadline();
  void clear_has_deadline();
  void set_has_signer();
  void clear_has_signer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr signer_;
  ::google::protobuf::uint32 network_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint32 deadline_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMTransfer_NEMMosaic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic) */ {
 public:
  NEMSignTx_NEMTransfer_NEMMosaic();
  virtual ~NEMSignTx_NEMTransfer_NEMMosaic();

  NEMSignTx_NEMTransfer_NEMMosaic(const NEMSignTx_NEMTransfer_NEMMosaic& from);

  inline NEMSignTx_NEMTransfer_NEMMosaic& operator=(const NEMSignTx_NEMTransfer_NEMMosaic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMTransfer_NEMMosaic(NEMSignTx_NEMTransfer_NEMMosaic&& from) noexcept
    : NEMSignTx_NEMTransfer_NEMMosaic() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMTransfer_NEMMosaic& operator=(NEMSignTx_NEMTransfer_NEMMosaic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMTransfer_NEMMosaic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMTransfer_NEMMosaic* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMTransfer_NEMMosaic*>(
               &_NEMSignTx_NEMTransfer_NEMMosaic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NEMSignTx_NEMTransfer_NEMMosaic* other);
  friend void swap(NEMSignTx_NEMTransfer_NEMMosaic& a, NEMSignTx_NEMTransfer_NEMMosaic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMTransfer_NEMMosaic* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransfer_NEMMosaic>(NULL);
  }

  NEMSignTx_NEMTransfer_NEMMosaic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransfer_NEMMosaic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMTransfer_NEMMosaic& from);
  void MergeFrom(const NEMSignTx_NEMTransfer_NEMMosaic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMTransfer_NEMMosaic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // optional string mosaic = 2;
  bool has_mosaic() const;
  void clear_mosaic();
  static const int kMosaicFieldNumber = 2;
  const ::std::string& mosaic() const;
  void set_mosaic(const ::std::string& value);
  #if LANG_CXX11
  void set_mosaic(::std::string&& value);
  #endif
  void set_mosaic(const char* value);
  void set_mosaic(const char* value, size_t size);
  ::std::string* mutable_mosaic();
  ::std::string* release_mosaic();
  void set_allocated_mosaic(::std::string* mosaic);

  // optional uint64 quantity = 3;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  ::google::protobuf::uint64 quantity() const;
  void set_quantity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
 private:
  void set_has_namespace_();
  void clear_has_namespace_();
  void set_has_mosaic();
  void clear_has_mosaic();
  void set_has_quantity();
  void clear_has_quantity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::internal::ArenaStringPtr mosaic_;
  ::google::protobuf::uint64 quantity_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMTransfer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMTransfer) */ {
 public:
  NEMSignTx_NEMTransfer();
  virtual ~NEMSignTx_NEMTransfer();

  NEMSignTx_NEMTransfer(const NEMSignTx_NEMTransfer& from);

  inline NEMSignTx_NEMTransfer& operator=(const NEMSignTx_NEMTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMTransfer(NEMSignTx_NEMTransfer&& from) noexcept
    : NEMSignTx_NEMTransfer() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMTransfer& operator=(NEMSignTx_NEMTransfer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMTransfer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMTransfer* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMTransfer*>(
               &_NEMSignTx_NEMTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(NEMSignTx_NEMTransfer* other);
  friend void swap(NEMSignTx_NEMTransfer& a, NEMSignTx_NEMTransfer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMTransfer* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransfer>(NULL);
  }

  NEMSignTx_NEMTransfer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMTransfer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMTransfer& from);
  void MergeFrom(const NEMSignTx_NEMTransfer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMTransfer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMTransfer_NEMMosaic NEMMosaic;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
  int mosaics_size() const;
  void clear_mosaics();
  static const int kMosaicsFieldNumber = 5;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* mutable_mosaics(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >*
      mutable_mosaics();
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic& mosaics(int index) const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* add_mosaics();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >&
      mosaics() const;

  // optional string recipient = 1;
  bool has_recipient() const;
  void clear_recipient();
  static const int kRecipientFieldNumber = 1;
  const ::std::string& recipient() const;
  void set_recipient(const ::std::string& value);
  #if LANG_CXX11
  void set_recipient(::std::string&& value);
  #endif
  void set_recipient(const char* value);
  void set_recipient(const char* value, size_t size);
  ::std::string* mutable_recipient();
  ::std::string* release_recipient();
  void set_allocated_recipient(::std::string* recipient);

  // optional bytes payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional bytes public_key = 4;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
 private:
  void set_has_recipient();
  void clear_has_recipient();
  void set_has_amount();
  void clear_has_amount();
  void set_has_payload();
  void clear_has_payload();
  void set_has_public_key();
  void clear_has_public_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic > mosaics_;
  ::google::protobuf::internal::ArenaStringPtr recipient_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::uint64 amount_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMProvisionNamespace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace) */ {
 public:
  NEMSignTx_NEMProvisionNamespace();
  virtual ~NEMSignTx_NEMProvisionNamespace();

  NEMSignTx_NEMProvisionNamespace(const NEMSignTx_NEMProvisionNamespace& from);

  inline NEMSignTx_NEMProvisionNamespace& operator=(const NEMSignTx_NEMProvisionNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMProvisionNamespace(NEMSignTx_NEMProvisionNamespace&& from) noexcept
    : NEMSignTx_NEMProvisionNamespace() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMProvisionNamespace& operator=(NEMSignTx_NEMProvisionNamespace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMProvisionNamespace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMProvisionNamespace* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMProvisionNamespace*>(
               &_NEMSignTx_NEMProvisionNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NEMSignTx_NEMProvisionNamespace* other);
  friend void swap(NEMSignTx_NEMProvisionNamespace& a, NEMSignTx_NEMProvisionNamespace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMProvisionNamespace* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMProvisionNamespace>(NULL);
  }

  NEMSignTx_NEMProvisionNamespace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMProvisionNamespace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMProvisionNamespace& from);
  void MergeFrom(const NEMSignTx_NEMProvisionNamespace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMProvisionNamespace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // optional string parent = 2;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 2;
  const ::std::string& parent() const;
  void set_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_parent(::std::string&& value);
  #endif
  void set_parent(const char* value);
  void set_parent(const char* value, size_t size);
  ::std::string* mutable_parent();
  ::std::string* release_parent();
  void set_allocated_parent(::std::string* parent);

  // optional string sink = 3;
  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 3;
  const ::std::string& sink() const;
  void set_sink(const ::std::string& value);
  #if LANG_CXX11
  void set_sink(::std::string&& value);
  #endif
  void set_sink(const char* value);
  void set_sink(const char* value, size_t size);
  ::std::string* mutable_sink();
  ::std::string* release_sink();
  void set_allocated_sink(::std::string* sink);

  // optional uint64 fee = 4;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 4;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
 private:
  void set_has_namespace_();
  void clear_has_namespace_();
  void set_has_parent();
  void clear_has_parent();
  void set_has_sink();
  void clear_has_sink();
  void set_has_fee();
  void clear_has_fee();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::internal::ArenaStringPtr parent_;
  ::google::protobuf::internal::ArenaStringPtr sink_;
  ::google::protobuf::uint64 fee_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition) */ {
 public:
  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition();
  virtual ~NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition();

  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from);

  inline NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& operator=(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition&& from) noexcept
    : NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& operator=(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition*>(
               &_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* other);
  friend void swap(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& a, NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(NULL);
  }

  NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from);
  void MergeFrom(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMMosaicLevy;
  static const NEMMosaicLevy MosaicLevy_Absolute =
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Absolute;
  static const NEMMosaicLevy MosaicLevy_Percentile =
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_MosaicLevy_Percentile;
  static inline bool NEMMosaicLevy_IsValid(int value) {
    return NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(value);
  }
  static const NEMMosaicLevy NEMMosaicLevy_MIN =
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_MIN;
  static const NEMMosaicLevy NEMMosaicLevy_MAX =
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_MAX;
  static const int NEMMosaicLevy_ARRAYSIZE =
    NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_NEMMosaicLevy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NEMMosaicLevy_descriptor() {
    return NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor();
  }
  static inline const ::std::string& NEMMosaicLevy_Name(NEMMosaicLevy value) {
    return NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_Name(value);
  }
  static inline bool NEMMosaicLevy_Parse(const ::std::string& name,
      NEMMosaicLevy* value) {
    return NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 networks = 15;
  int networks_size() const;
  void clear_networks();
  static const int kNetworksFieldNumber = 15;
  ::google::protobuf::uint32 networks(int index) const;
  void set_networks(int index, ::google::protobuf::uint32 value);
  void add_networks(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      networks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_networks();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string ticker = 2;
  bool has_ticker() const;
  void clear_ticker();
  static const int kTickerFieldNumber = 2;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // optional string namespace = 3;
  bool has_namespace_() const;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 3;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // optional string mosaic = 4;
  bool has_mosaic() const;
  void clear_mosaic();
  static const int kMosaicFieldNumber = 4;
  const ::std::string& mosaic() const;
  void set_mosaic(const ::std::string& value);
  #if LANG_CXX11
  void set_mosaic(::std::string&& value);
  #endif
  void set_mosaic(const char* value);
  void set_mosaic(const char* value, size_t size);
  ::std::string* mutable_mosaic();
  ::std::string* release_mosaic();
  void set_allocated_mosaic(::std::string* mosaic);

  // optional string levy_address = 8;
  bool has_levy_address() const;
  void clear_levy_address();
  static const int kLevyAddressFieldNumber = 8;
  const ::std::string& levy_address() const;
  void set_levy_address(const ::std::string& value);
  #if LANG_CXX11
  void set_levy_address(::std::string&& value);
  #endif
  void set_levy_address(const char* value);
  void set_levy_address(const char* value, size_t size);
  ::std::string* mutable_levy_address();
  ::std::string* release_levy_address();
  void set_allocated_levy_address(::std::string* levy_address);

  // optional string levy_namespace = 9;
  bool has_levy_namespace() const;
  void clear_levy_namespace();
  static const int kLevyNamespaceFieldNumber = 9;
  const ::std::string& levy_namespace() const;
  void set_levy_namespace(const ::std::string& value);
  #if LANG_CXX11
  void set_levy_namespace(::std::string&& value);
  #endif
  void set_levy_namespace(const char* value);
  void set_levy_namespace(const char* value, size_t size);
  ::std::string* mutable_levy_namespace();
  ::std::string* release_levy_namespace();
  void set_allocated_levy_namespace(::std::string* levy_namespace);

  // optional string levy_mosaic = 10;
  bool has_levy_mosaic() const;
  void clear_levy_mosaic();
  static const int kLevyMosaicFieldNumber = 10;
  const ::std::string& levy_mosaic() const;
  void set_levy_mosaic(const ::std::string& value);
  #if LANG_CXX11
  void set_levy_mosaic(::std::string&& value);
  #endif
  void set_levy_mosaic(const char* value);
  void set_levy_mosaic(const char* value, size_t size);
  ::std::string* mutable_levy_mosaic();
  ::std::string* release_levy_mosaic();
  void set_allocated_levy_mosaic(::std::string* levy_mosaic);

  // optional string description = 14;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 14;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional uint64 fee = 7;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 7;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint32 divisibility = 5;
  bool has_divisibility() const;
  void clear_divisibility();
  static const int kDivisibilityFieldNumber = 5;
  ::google::protobuf::uint32 divisibility() const;
  void set_divisibility(::google::protobuf::uint32 value);

  // optional bool mutable_supply = 12;
  bool has_mutable_supply() const;
  void clear_mutable_supply();
  static const int kMutableSupplyFieldNumber = 12;
  bool mutable_supply() const;
  void set_mutable_supply(bool value);

  // optional bool transferable = 13;
  bool has_transferable() const;
  void clear_transferable();
  static const int kTransferableFieldNumber = 13;
  bool transferable() const;
  void set_transferable(bool value);

  // optional uint64 supply = 11;
  bool has_supply() const;
  void clear_supply();
  static const int kSupplyFieldNumber = 11;
  ::google::protobuf::uint64 supply() const;
  void set_supply(::google::protobuf::uint64 value);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
  bool has_levy() const;
  void clear_levy();
  static const int kLevyFieldNumber = 6;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy levy() const;
  void set_levy(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ticker();
  void clear_has_ticker();
  void set_has_namespace_();
  void clear_has_namespace_();
  void set_has_mosaic();
  void clear_has_mosaic();
  void set_has_divisibility();
  void clear_has_divisibility();
  void set_has_levy();
  void clear_has_levy();
  void set_has_fee();
  void clear_has_fee();
  void set_has_levy_address();
  void clear_has_levy_address();
  void set_has_levy_namespace();
  void clear_has_levy_namespace();
  void set_has_levy_mosaic();
  void clear_has_levy_mosaic();
  void set_has_supply();
  void clear_has_supply();
  void set_has_mutable_supply();
  void clear_has_mutable_supply();
  void set_has_transferable();
  void clear_has_transferable();
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > networks_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::internal::ArenaStringPtr mosaic_;
  ::google::protobuf::internal::ArenaStringPtr levy_address_;
  ::google::protobuf::internal::ArenaStringPtr levy_namespace_;
  ::google::protobuf::internal::ArenaStringPtr levy_mosaic_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint32 divisibility_;
  bool mutable_supply_;
  bool transferable_;
  ::google::protobuf::uint64 supply_;
  int levy_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMMosaicCreation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation) */ {
 public:
  NEMSignTx_NEMMosaicCreation();
  virtual ~NEMSignTx_NEMMosaicCreation();

  NEMSignTx_NEMMosaicCreation(const NEMSignTx_NEMMosaicCreation& from);

  inline NEMSignTx_NEMMosaicCreation& operator=(const NEMSignTx_NEMMosaicCreation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMMosaicCreation(NEMSignTx_NEMMosaicCreation&& from) noexcept
    : NEMSignTx_NEMMosaicCreation() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMMosaicCreation& operator=(NEMSignTx_NEMMosaicCreation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMMosaicCreation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMMosaicCreation* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMMosaicCreation*>(
               &_NEMSignTx_NEMMosaicCreation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NEMSignTx_NEMMosaicCreation* other);
  friend void swap(NEMSignTx_NEMMosaicCreation& a, NEMSignTx_NEMMosaicCreation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMMosaicCreation* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicCreation>(NULL);
  }

  NEMSignTx_NEMMosaicCreation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicCreation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMMosaicCreation& from);
  void MergeFrom(const NEMSignTx_NEMMosaicCreation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMMosaicCreation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition NEMMosaicDefinition;

  // accessors -------------------------------------------------------

  // optional string sink = 2;
  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 2;
  const ::std::string& sink() const;
  void set_sink(const ::std::string& value);
  #if LANG_CXX11
  void set_sink(::std::string&& value);
  #endif
  void set_sink(const char* value);
  void set_sink(const char* value, size_t size);
  ::std::string* mutable_sink();
  ::std::string* release_sink();
  void set_allocated_sink(::std::string* sink);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
  bool has_definition() const;
  void clear_definition();
  static const int kDefinitionFieldNumber = 1;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& _internal_definition() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& definition() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* release_definition();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* mutable_definition();
  void set_allocated_definition(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* definition);

  // optional uint64 fee = 3;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 3;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
 private:
  void set_has_definition();
  void clear_has_definition();
  void set_has_sink();
  void clear_has_sink();
  void set_has_fee();
  void clear_has_fee();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sink_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* definition_;
  ::google::protobuf::uint64 fee_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMMosaicSupplyChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange) */ {
 public:
  NEMSignTx_NEMMosaicSupplyChange();
  virtual ~NEMSignTx_NEMMosaicSupplyChange();

  NEMSignTx_NEMMosaicSupplyChange(const NEMSignTx_NEMMosaicSupplyChange& from);

  inline NEMSignTx_NEMMosaicSupplyChange& operator=(const NEMSignTx_NEMMosaicSupplyChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMMosaicSupplyChange(NEMSignTx_NEMMosaicSupplyChange&& from) noexcept
    : NEMSignTx_NEMMosaicSupplyChange() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMMosaicSupplyChange& operator=(NEMSignTx_NEMMosaicSupplyChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMMosaicSupplyChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMMosaicSupplyChange* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMMosaicSupplyChange*>(
               &_NEMSignTx_NEMMosaicSupplyChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(NEMSignTx_NEMMosaicSupplyChange* other);
  friend void swap(NEMSignTx_NEMMosaicSupplyChange& a, NEMSignTx_NEMMosaicSupplyChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMMosaicSupplyChange* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicSupplyChange>(NULL);
  }

  NEMSignTx_NEMMosaicSupplyChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMMosaicSupplyChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMMosaicSupplyChange& from);
  void MergeFrom(const NEMSignTx_NEMMosaicSupplyChange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMMosaicSupplyChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSupplyChangeType;
  static const NEMSupplyChangeType SupplyChange_Increase =
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Increase;
  static const NEMSupplyChangeType SupplyChange_Decrease =
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_SupplyChange_Decrease;
  static inline bool NEMSupplyChangeType_IsValid(int value) {
    return NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(value);
  }
  static const NEMSupplyChangeType NEMSupplyChangeType_MIN =
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_MIN;
  static const NEMSupplyChangeType NEMSupplyChangeType_MAX =
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_MAX;
  static const int NEMSupplyChangeType_ARRAYSIZE =
    NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_NEMSupplyChangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NEMSupplyChangeType_descriptor() {
    return NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor();
  }
  static inline const ::std::string& NEMSupplyChangeType_Name(NEMSupplyChangeType value) {
    return NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_Name(value);
  }
  static inline bool NEMSupplyChangeType_Parse(const ::std::string& name,
      NEMSupplyChangeType* value) {
    return NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // optional string mosaic = 2;
  bool has_mosaic() const;
  void clear_mosaic();
  static const int kMosaicFieldNumber = 2;
  const ::std::string& mosaic() const;
  void set_mosaic(const ::std::string& value);
  #if LANG_CXX11
  void set_mosaic(::std::string&& value);
  #endif
  void set_mosaic(const char* value);
  void set_mosaic(const char* value, size_t size);
  ::std::string* mutable_mosaic();
  ::std::string* release_mosaic();
  void set_allocated_mosaic(::std::string* mosaic);

  // optional uint64 delta = 4;
  bool has_delta() const;
  void clear_delta();
  static const int kDeltaFieldNumber = 4;
  ::google::protobuf::uint64 delta() const;
  void set_delta(::google::protobuf::uint64 value);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType type() const;
  void set_type(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
 private:
  void set_has_namespace_();
  void clear_has_namespace_();
  void set_has_mosaic();
  void clear_has_mosaic();
  void set_has_type();
  void clear_has_type();
  void set_has_delta();
  void clear_has_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::internal::ArenaStringPtr mosaic_;
  ::google::protobuf::uint64 delta_;
  int type_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMAggregateModification_NEMCosignatoryModification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification) */ {
 public:
  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification();
  virtual ~NEMSignTx_NEMAggregateModification_NEMCosignatoryModification();

  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from);

  inline NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& operator=(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification&& from) noexcept
    : NEMSignTx_NEMAggregateModification_NEMCosignatoryModification() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& operator=(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification*>(
               &_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* other);
  friend void swap(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& a, NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>(NULL);
  }

  NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from);
  void MergeFrom(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMModificationType;
  static const NEMModificationType CosignatoryModification_Add =
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Add;
  static const NEMModificationType CosignatoryModification_Delete =
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_CosignatoryModification_Delete;
  static inline bool NEMModificationType_IsValid(int value) {
    return NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(value);
  }
  static const NEMModificationType NEMModificationType_MIN =
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_MIN;
  static const NEMModificationType NEMModificationType_MAX =
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_MAX;
  static const int NEMModificationType_ARRAYSIZE =
    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_NEMModificationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NEMModificationType_descriptor() {
    return NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor();
  }
  static inline const ::std::string& NEMModificationType_Name(NEMModificationType value) {
    return NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_Name(value);
  }
  static inline bool NEMModificationType_Parse(const ::std::string& name,
      NEMModificationType* value) {
    return NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType type() const;
  void set_type(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_public_key();
  void clear_has_public_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  int type_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMAggregateModification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification) */ {
 public:
  NEMSignTx_NEMAggregateModification();
  virtual ~NEMSignTx_NEMAggregateModification();

  NEMSignTx_NEMAggregateModification(const NEMSignTx_NEMAggregateModification& from);

  inline NEMSignTx_NEMAggregateModification& operator=(const NEMSignTx_NEMAggregateModification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMAggregateModification(NEMSignTx_NEMAggregateModification&& from) noexcept
    : NEMSignTx_NEMAggregateModification() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMAggregateModification& operator=(NEMSignTx_NEMAggregateModification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMAggregateModification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMAggregateModification* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMAggregateModification*>(
               &_NEMSignTx_NEMAggregateModification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(NEMSignTx_NEMAggregateModification* other);
  friend void swap(NEMSignTx_NEMAggregateModification& a, NEMSignTx_NEMAggregateModification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMAggregateModification* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMAggregateModification>(NULL);
  }

  NEMSignTx_NEMAggregateModification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMAggregateModification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMAggregateModification& from);
  void MergeFrom(const NEMSignTx_NEMAggregateModification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMAggregateModification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMAggregateModification_NEMCosignatoryModification NEMCosignatoryModification;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
  int modifications_size() const;
  void clear_modifications();
  static const int kModificationsFieldNumber = 1;
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* mutable_modifications(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >*
      mutable_modifications();
  const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& modifications(int index) const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* add_modifications();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >&
      modifications() const;

  // optional sint32 relative_change = 2;
  bool has_relative_change() const;
  void clear_relative_change();
  static const int kRelativeChangeFieldNumber = 2;
  ::google::protobuf::int32 relative_change() const;
  void set_relative_change(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
 private:
  void set_has_relative_change();
  void clear_has_relative_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification > modifications_;
  ::google::protobuf::int32 relative_change_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx_NEMImportanceTransfer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer) */ {
 public:
  NEMSignTx_NEMImportanceTransfer();
  virtual ~NEMSignTx_NEMImportanceTransfer();

  NEMSignTx_NEMImportanceTransfer(const NEMSignTx_NEMImportanceTransfer& from);

  inline NEMSignTx_NEMImportanceTransfer& operator=(const NEMSignTx_NEMImportanceTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx_NEMImportanceTransfer(NEMSignTx_NEMImportanceTransfer&& from) noexcept
    : NEMSignTx_NEMImportanceTransfer() {
    *this = ::std::move(from);
  }

  inline NEMSignTx_NEMImportanceTransfer& operator=(NEMSignTx_NEMImportanceTransfer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx_NEMImportanceTransfer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx_NEMImportanceTransfer* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx_NEMImportanceTransfer*>(
               &_NEMSignTx_NEMImportanceTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(NEMSignTx_NEMImportanceTransfer* other);
  friend void swap(NEMSignTx_NEMImportanceTransfer& a, NEMSignTx_NEMImportanceTransfer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx_NEMImportanceTransfer* New() const final {
    return CreateMaybeMessage<NEMSignTx_NEMImportanceTransfer>(NULL);
  }

  NEMSignTx_NEMImportanceTransfer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx_NEMImportanceTransfer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx_NEMImportanceTransfer& from);
  void MergeFrom(const NEMSignTx_NEMImportanceTransfer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx_NEMImportanceTransfer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMImportanceTransferMode;
  static const NEMImportanceTransferMode ImportanceTransfer_Activate =
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Activate;
  static const NEMImportanceTransferMode ImportanceTransfer_Deactivate =
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_ImportanceTransfer_Deactivate;
  static inline bool NEMImportanceTransferMode_IsValid(int value) {
    return NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(value);
  }
  static const NEMImportanceTransferMode NEMImportanceTransferMode_MIN =
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_MIN;
  static const NEMImportanceTransferMode NEMImportanceTransferMode_MAX =
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_MAX;
  static const int NEMImportanceTransferMode_ARRAYSIZE =
    NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_NEMImportanceTransferMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NEMImportanceTransferMode_descriptor() {
    return NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor();
  }
  static inline const ::std::string& NEMImportanceTransferMode_Name(NEMImportanceTransferMode value) {
    return NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_Name(value);
  }
  static inline bool NEMImportanceTransferMode_Parse(const ::std::string& name,
      NEMImportanceTransferMode* value) {
    return NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode mode() const;
  void set_mode(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
 private:
  void set_has_mode();
  void clear_has_mode();
  void set_has_public_key();
  void clear_has_public_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  int mode_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignTx) */ {
 public:
  NEMSignTx();
  virtual ~NEMSignTx();

  NEMSignTx(const NEMSignTx& from);

  inline NEMSignTx& operator=(const NEMSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignTx(NEMSignTx&& from) noexcept
    : NEMSignTx() {
    *this = ::std::move(from);
  }

  inline NEMSignTx& operator=(NEMSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignTx* internal_default_instance() {
    return reinterpret_cast<const NEMSignTx*>(
               &_NEMSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(NEMSignTx* other);
  friend void swap(NEMSignTx& a, NEMSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignTx* New() const final {
    return CreateMaybeMessage<NEMSignTx>(NULL);
  }

  NEMSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignTx& from);
  void MergeFrom(const NEMSignTx& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NEMSignTx_NEMTransactionCommon NEMTransactionCommon;
  typedef NEMSignTx_NEMTransfer NEMTransfer;
  typedef NEMSignTx_NEMProvisionNamespace NEMProvisionNamespace;
  typedef NEMSignTx_NEMMosaicCreation NEMMosaicCreation;
  typedef NEMSignTx_NEMMosaicSupplyChange NEMMosaicSupplyChange;
  typedef NEMSignTx_NEMAggregateModification NEMAggregateModification;
  typedef NEMSignTx_NEMImportanceTransfer NEMImportanceTransfer;

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& _internal_transaction() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& transaction() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* release_transaction();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* mutable_transaction();
  void set_allocated_transaction(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* transaction);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 2;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& _internal_multisig() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& multisig() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* release_multisig();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* mutable_multisig();
  void set_allocated_multisig(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* multisig);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
  bool has_transfer() const;
  void clear_transfer();
  static const int kTransferFieldNumber = 3;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer& _internal_transfer() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer& transfer() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* release_transfer();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* mutable_transfer();
  void set_allocated_transfer(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* transfer);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
  bool has_provision_namespace() const;
  void clear_provision_namespace();
  static const int kProvisionNamespaceFieldNumber = 5;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace& _internal_provision_namespace() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace& provision_namespace() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* release_provision_namespace();
  ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* mutable_provision_namespace();
  void set_allocated_provision_namespace(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* provision_namespace);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
  bool has_mosaic_creation() const;
  void clear_mosaic_creation();
  static const int kMosaicCreationFieldNumber = 6;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation& _internal_mosaic_creation() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation& mosaic_creation() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* release_mosaic_creation();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* mutable_mosaic_creation();
  void set_allocated_mosaic_creation(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* mosaic_creation);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
  bool has_supply_change() const;
  void clear_supply_change();
  static const int kSupplyChangeFieldNumber = 7;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange& _internal_supply_change() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange& supply_change() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* release_supply_change();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* mutable_supply_change();
  void set_allocated_supply_change(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* supply_change);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
  bool has_aggregate_modification() const;
  void clear_aggregate_modification();
  static const int kAggregateModificationFieldNumber = 8;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification& _internal_aggregate_modification() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification& aggregate_modification() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* release_aggregate_modification();
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* mutable_aggregate_modification();
  void set_allocated_aggregate_modification(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* aggregate_modification);

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
  bool has_importance_transfer() const;
  void clear_importance_transfer();
  static const int kImportanceTransferFieldNumber = 9;
  private:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer& _internal_importance_transfer() const;
  public:
  const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer& importance_transfer() const;
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* release_importance_transfer();
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* mutable_importance_transfer();
  void set_allocated_importance_transfer(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* importance_transfer);

  // optional bool cosigning = 4;
  bool has_cosigning() const;
  void clear_cosigning();
  static const int kCosigningFieldNumber = 4;
  bool cosigning() const;
  void set_cosigning(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignTx)
 private:
  void set_has_transaction();
  void clear_has_transaction();
  void set_has_multisig();
  void clear_has_multisig();
  void set_has_transfer();
  void clear_has_transfer();
  void set_has_cosigning();
  void clear_has_cosigning();
  void set_has_provision_namespace();
  void clear_has_provision_namespace();
  void set_has_mosaic_creation();
  void clear_has_mosaic_creation();
  void set_has_supply_change();
  void clear_has_supply_change();
  void set_has_aggregate_modification();
  void clear_has_aggregate_modification();
  void set_has_importance_transfer();
  void clear_has_importance_transfer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* transaction_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* multisig_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* transfer_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* provision_namespace_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* mosaic_creation_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* supply_change_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* aggregate_modification_;
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* importance_transfer_;
  bool cosigning_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMSignedTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMSignedTx) */ {
 public:
  NEMSignedTx();
  virtual ~NEMSignedTx();

  NEMSignedTx(const NEMSignedTx& from);

  inline NEMSignedTx& operator=(const NEMSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMSignedTx(NEMSignedTx&& from) noexcept
    : NEMSignedTx() {
    *this = ::std::move(from);
  }

  inline NEMSignedTx& operator=(NEMSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMSignedTx* internal_default_instance() {
    return reinterpret_cast<const NEMSignedTx*>(
               &_NEMSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(NEMSignedTx* other);
  friend void swap(NEMSignedTx& a, NEMSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMSignedTx* New() const final {
    return CreateMaybeMessage<NEMSignedTx>(NULL);
  }

  NEMSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMSignedTx& from);
  void MergeFrom(const NEMSignedTx& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMSignedTx)
 private:
  void set_has_data();
  void clear_has_data();
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMDecryptMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMDecryptMessage) */ {
 public:
  NEMDecryptMessage();
  virtual ~NEMDecryptMessage();

  NEMDecryptMessage(const NEMDecryptMessage& from);

  inline NEMDecryptMessage& operator=(const NEMDecryptMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMDecryptMessage(NEMDecryptMessage&& from) noexcept
    : NEMDecryptMessage() {
    *this = ::std::move(from);
  }

  inline NEMDecryptMessage& operator=(NEMDecryptMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMDecryptMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMDecryptMessage* internal_default_instance() {
    return reinterpret_cast<const NEMDecryptMessage*>(
               &_NEMDecryptMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(NEMDecryptMessage* other);
  friend void swap(NEMDecryptMessage& a, NEMDecryptMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMDecryptMessage* New() const final {
    return CreateMaybeMessage<NEMDecryptMessage>(NULL);
  }

  NEMDecryptMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMDecryptMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMDecryptMessage& from);
  void MergeFrom(const NEMDecryptMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMDecryptMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes public_key = 3;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes payload = 4;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 4;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional uint32 network = 2;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  ::google::protobuf::uint32 network() const;
  void set_network(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMDecryptMessage)
 private:
  void set_has_network();
  void clear_has_network();
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_payload();
  void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 network_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NEMDecryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.nem.NEMDecryptedMessage) */ {
 public:
  NEMDecryptedMessage();
  virtual ~NEMDecryptedMessage();

  NEMDecryptedMessage(const NEMDecryptedMessage& from);

  inline NEMDecryptedMessage& operator=(const NEMDecryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NEMDecryptedMessage(NEMDecryptedMessage&& from) noexcept
    : NEMDecryptedMessage() {
    *this = ::std::move(from);
  }

  inline NEMDecryptedMessage& operator=(NEMDecryptedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NEMDecryptedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NEMDecryptedMessage* internal_default_instance() {
    return reinterpret_cast<const NEMDecryptedMessage*>(
               &_NEMDecryptedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(NEMDecryptedMessage* other);
  friend void swap(NEMDecryptedMessage& a, NEMDecryptedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NEMDecryptedMessage* New() const final {
    return CreateMaybeMessage<NEMDecryptedMessage>(NULL);
  }

  NEMDecryptedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NEMDecryptedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NEMDecryptedMessage& from);
  void MergeFrom(const NEMDecryptedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NEMDecryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.nem.NEMDecryptedMessage)
 private:
  void set_has_payload();
  void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  friend struct ::protobuf_messages_2dnem_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NEMGetAddress

// repeated uint32 address_n = 1;
inline int NEMGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void NEMGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 NEMGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMGetAddress.address_n)
  return address_n_.Get(index);
}
inline void NEMGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMGetAddress.address_n)
}
inline void NEMGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NEMGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NEMGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMGetAddress.address_n)
  return &address_n_;
}

// optional uint32 network = 2;
inline bool NEMGetAddress::has_network() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMGetAddress::set_has_network() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMGetAddress::clear_has_network() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMGetAddress::clear_network() {
  network_ = 0u;
  clear_has_network();
}
inline ::google::protobuf::uint32 NEMGetAddress::network() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMGetAddress.network)
  return network_;
}
inline void NEMGetAddress::set_network(::google::protobuf::uint32 value) {
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMGetAddress.network)
}

// optional bool show_display = 3;
inline bool NEMGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMGetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMGetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMGetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool NEMGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMGetAddress.show_display)
  return show_display_;
}
inline void NEMGetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMGetAddress.show_display)
}

// -------------------------------------------------------------------

// NEMAddress

// required string address = 1;
inline bool NEMAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMAddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMAddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& NEMAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMAddress.address)
  return address_.GetNoArena();
}
inline void NEMAddress::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMAddress.address)
}
#if LANG_CXX11
inline void NEMAddress::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMAddress.address)
}
#endif
inline void NEMAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMAddress.address)
}
inline void NEMAddress::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMAddress.address)
}
inline ::std::string* NEMAddress::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMAddress.address)
  if (!has_address()) {
    return NULL;
  }
  clear_has_address();
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMAddress.address)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMTransactionCommon

// repeated uint32 address_n = 1;
inline int NEMSignTx_NEMTransactionCommon::address_n_size() const {
  return address_n_.size();
}
inline void NEMSignTx_NEMTransactionCommon::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMTransactionCommon::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.address_n)
  return address_n_.Get(index);
}
inline void NEMSignTx_NEMTransactionCommon::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.address_n)
}
inline void NEMSignTx_NEMTransactionCommon::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NEMSignTx_NEMTransactionCommon::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NEMSignTx_NEMTransactionCommon::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.address_n)
  return &address_n_;
}

// optional uint32 network = 2;
inline bool NEMSignTx_NEMTransactionCommon::has_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMTransactionCommon::set_has_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_has_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_network() {
  network_ = 0u;
  clear_has_network();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMTransactionCommon::network() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.network)
  return network_;
}
inline void NEMSignTx_NEMTransactionCommon::set_network(::google::protobuf::uint32 value) {
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.network)
}

// optional uint32 timestamp = 3;
inline bool NEMSignTx_NEMTransactionCommon::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMTransactionCommon::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMTransactionCommon::timestamp() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.timestamp)
  return timestamp_;
}
inline void NEMSignTx_NEMTransactionCommon::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.timestamp)
}

// optional uint64 fee = 4;
inline bool NEMSignTx_NEMTransactionCommon::has_fee() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx_NEMTransactionCommon::set_has_fee() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_has_fee() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_fee() {
  fee_ = GOOGLE_ULONGLONG(0);
  clear_has_fee();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMTransactionCommon::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.fee)
  return fee_;
}
inline void NEMSignTx_NEMTransactionCommon::set_fee(::google::protobuf::uint64 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.fee)
}

// optional uint32 deadline = 5;
inline bool NEMSignTx_NEMTransactionCommon::has_deadline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NEMSignTx_NEMTransactionCommon::set_has_deadline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_deadline() {
  deadline_ = 0u;
  clear_has_deadline();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMTransactionCommon::deadline() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.deadline)
  return deadline_;
}
inline void NEMSignTx_NEMTransactionCommon::set_deadline(::google::protobuf::uint32 value) {
  set_has_deadline();
  deadline_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.deadline)
}

// optional bytes signer = 6;
inline bool NEMSignTx_NEMTransactionCommon::has_signer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMTransactionCommon::set_has_signer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_has_signer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMTransactionCommon::clear_signer() {
  signer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signer();
}
inline const ::std::string& NEMSignTx_NEMTransactionCommon::signer() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
  return signer_.GetNoArena();
}
inline void NEMSignTx_NEMTransactionCommon::set_signer(const ::std::string& value) {
  set_has_signer();
  signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransactionCommon::set_signer(::std::string&& value) {
  set_has_signer();
  signer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
}
#endif
inline void NEMSignTx_NEMTransactionCommon::set_signer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signer();
  signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
}
inline void NEMSignTx_NEMTransactionCommon::set_signer(const void* value, size_t size) {
  set_has_signer();
  signer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
}
inline ::std::string* NEMSignTx_NEMTransactionCommon::mutable_signer() {
  set_has_signer();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
  return signer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransactionCommon::release_signer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
  if (!has_signer()) {
    return NULL;
  }
  clear_has_signer();
  return signer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransactionCommon::set_allocated_signer(::std::string* signer) {
  if (signer != NULL) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
  signer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signer);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon.signer)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMTransfer_NEMMosaic

// optional string namespace = 1;
inline bool NEMSignTx_NEMTransfer_NEMMosaic::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_();
}
inline const ::std::string& NEMSignTx_NEMTransfer_NEMMosaic::namespace_() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
  return namespace__.GetNoArena();
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_namespace_(::std::string&& value) {
  set_has_namespace_();
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
}
#endif
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
}
inline ::std::string* NEMSignTx_NEMTransfer_NEMMosaic::mutable_namespace_() {
  set_has_namespace_();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransfer_NEMMosaic::release_namespace_() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
  if (!has_namespace_()) {
    return NULL;
  }
  clear_has_namespace_();
  return namespace__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    set_has_namespace_();
  } else {
    clear_has_namespace_();
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace)
}

// optional string mosaic = 2;
inline bool NEMSignTx_NEMTransfer_NEMMosaic::has_mosaic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_has_mosaic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_has_mosaic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_mosaic() {
  mosaic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mosaic();
}
inline const ::std::string& NEMSignTx_NEMTransfer_NEMMosaic::mosaic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
  return mosaic_.GetNoArena();
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_mosaic(const ::std::string& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_mosaic(::std::string&& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
}
#endif
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_mosaic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_mosaic(const char* value, size_t size) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
}
inline ::std::string* NEMSignTx_NEMTransfer_NEMMosaic::mutable_mosaic() {
  set_has_mosaic();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
  return mosaic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransfer_NEMMosaic::release_mosaic() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
  if (!has_mosaic()) {
    return NULL;
  }
  clear_has_mosaic();
  return mosaic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_allocated_mosaic(::std::string* mosaic) {
  if (mosaic != NULL) {
    set_has_mosaic();
  } else {
    clear_has_mosaic();
  }
  mosaic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mosaic);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic)
}

// optional uint64 quantity = 3;
inline bool NEMSignTx_NEMTransfer_NEMMosaic::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::clear_quantity() {
  quantity_ = GOOGLE_ULONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMTransfer_NEMMosaic::quantity() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.quantity)
  return quantity_;
}
inline void NEMSignTx_NEMTransfer_NEMMosaic::set_quantity(::google::protobuf::uint64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.quantity)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMTransfer

// optional string recipient = 1;
inline bool NEMSignTx_NEMTransfer::has_recipient() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMTransfer::set_has_recipient() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMTransfer::clear_has_recipient() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMTransfer::clear_recipient() {
  recipient_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recipient();
}
inline const ::std::string& NEMSignTx_NEMTransfer::recipient() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
  return recipient_.GetNoArena();
}
inline void NEMSignTx_NEMTransfer::set_recipient(const ::std::string& value) {
  set_has_recipient();
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransfer::set_recipient(::std::string&& value) {
  set_has_recipient();
  recipient_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
}
#endif
inline void NEMSignTx_NEMTransfer::set_recipient(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recipient();
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
}
inline void NEMSignTx_NEMTransfer::set_recipient(const char* value, size_t size) {
  set_has_recipient();
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
}
inline ::std::string* NEMSignTx_NEMTransfer::mutable_recipient() {
  set_has_recipient();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
  return recipient_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransfer::release_recipient() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
  if (!has_recipient()) {
    return NULL;
  }
  clear_has_recipient();
  return recipient_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransfer::set_allocated_recipient(::std::string* recipient) {
  if (recipient != NULL) {
    set_has_recipient();
  } else {
    clear_has_recipient();
  }
  recipient_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipient);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient)
}

// optional uint64 amount = 2;
inline bool NEMSignTx_NEMTransfer::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx_NEMTransfer::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx_NEMTransfer::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx_NEMTransfer::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMTransfer::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.amount)
  return amount_;
}
inline void NEMSignTx_NEMTransfer::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.amount)
}

// optional bytes payload = 3;
inline bool NEMSignTx_NEMTransfer::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMTransfer::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMTransfer::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMTransfer::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& NEMSignTx_NEMTransfer::payload() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
  return payload_.GetNoArena();
}
inline void NEMSignTx_NEMTransfer::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransfer::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
}
#endif
inline void NEMSignTx_NEMTransfer::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
}
inline void NEMSignTx_NEMTransfer::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
}
inline ::std::string* NEMSignTx_NEMTransfer::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransfer::release_payload() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
  if (!has_payload()) {
    return NULL;
  }
  clear_has_payload();
  return payload_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransfer::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.payload)
}

// optional bytes public_key = 4;
inline bool NEMSignTx_NEMTransfer::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMTransfer::set_has_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMTransfer::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMTransfer::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& NEMSignTx_NEMTransfer::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
  return public_key_.GetNoArena();
}
inline void NEMSignTx_NEMTransfer::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
}
#if LANG_CXX11
inline void NEMSignTx_NEMTransfer::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
}
#endif
inline void NEMSignTx_NEMTransfer::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
}
inline void NEMSignTx_NEMTransfer::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
}
inline ::std::string* NEMSignTx_NEMTransfer::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMTransfer::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMTransfer::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.public_key)
}

// repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
inline int NEMSignTx_NEMTransfer::mosaics_size() const {
  return mosaics_.size();
}
inline void NEMSignTx_NEMTransfer::clear_mosaics() {
  mosaics_.Clear();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* NEMSignTx_NEMTransfer::mutable_mosaics(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics)
  return mosaics_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >*
NEMSignTx_NEMTransfer::mutable_mosaics() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics)
  return &mosaics_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic& NEMSignTx_NEMTransfer::mosaics(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics)
  return mosaics_.Get(index);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* NEMSignTx_NEMTransfer::add_mosaics() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics)
  return mosaics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >&
NEMSignTx_NEMTransfer::mosaics() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics)
  return mosaics_;
}

// -------------------------------------------------------------------

// NEMSignTx_NEMProvisionNamespace

// optional string namespace = 1;
inline bool NEMSignTx_NEMProvisionNamespace::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMProvisionNamespace::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_();
}
inline const ::std::string& NEMSignTx_NEMProvisionNamespace::namespace_() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
  return namespace__.GetNoArena();
}
inline void NEMSignTx_NEMProvisionNamespace::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
}
#if LANG_CXX11
inline void NEMSignTx_NEMProvisionNamespace::set_namespace_(::std::string&& value) {
  set_has_namespace_();
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
}
#endif
inline void NEMSignTx_NEMProvisionNamespace::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
}
inline void NEMSignTx_NEMProvisionNamespace::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::mutable_namespace_() {
  set_has_namespace_();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::release_namespace_() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
  if (!has_namespace_()) {
    return NULL;
  }
  clear_has_namespace_();
  return namespace__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMProvisionNamespace::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    set_has_namespace_();
  } else {
    clear_has_namespace_();
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace)
}

// optional string parent = 2;
inline bool NEMSignTx_NEMProvisionNamespace::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMProvisionNamespace::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_parent() {
  parent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent();
}
inline const ::std::string& NEMSignTx_NEMProvisionNamespace::parent() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
  return parent_.GetNoArena();
}
inline void NEMSignTx_NEMProvisionNamespace::set_parent(const ::std::string& value) {
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
}
#if LANG_CXX11
inline void NEMSignTx_NEMProvisionNamespace::set_parent(::std::string&& value) {
  set_has_parent();
  parent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
}
#endif
inline void NEMSignTx_NEMProvisionNamespace::set_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
}
inline void NEMSignTx_NEMProvisionNamespace::set_parent(const char* value, size_t size) {
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::mutable_parent() {
  set_has_parent();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
  return parent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::release_parent() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
  if (!has_parent()) {
    return NULL;
  }
  clear_has_parent();
  return parent_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMProvisionNamespace::set_allocated_parent(::std::string* parent) {
  if (parent != NULL) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  parent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent)
}

// optional string sink = 3;
inline bool NEMSignTx_NEMProvisionNamespace::has_sink() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMProvisionNamespace::set_has_sink() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_has_sink() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_sink() {
  sink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sink();
}
inline const ::std::string& NEMSignTx_NEMProvisionNamespace::sink() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
  return sink_.GetNoArena();
}
inline void NEMSignTx_NEMProvisionNamespace::set_sink(const ::std::string& value) {
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
}
#if LANG_CXX11
inline void NEMSignTx_NEMProvisionNamespace::set_sink(::std::string&& value) {
  set_has_sink();
  sink_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
}
#endif
inline void NEMSignTx_NEMProvisionNamespace::set_sink(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
}
inline void NEMSignTx_NEMProvisionNamespace::set_sink(const char* value, size_t size) {
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::mutable_sink() {
  set_has_sink();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
  return sink_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMProvisionNamespace::release_sink() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
  if (!has_sink()) {
    return NULL;
  }
  clear_has_sink();
  return sink_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMProvisionNamespace::set_allocated_sink(::std::string* sink) {
  if (sink != NULL) {
    set_has_sink();
  } else {
    clear_has_sink();
  }
  sink_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sink);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink)
}

// optional uint64 fee = 4;
inline bool NEMSignTx_NEMProvisionNamespace::has_fee() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx_NEMProvisionNamespace::set_has_fee() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_has_fee() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx_NEMProvisionNamespace::clear_fee() {
  fee_ = GOOGLE_ULONGLONG(0);
  clear_has_fee();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMProvisionNamespace::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.fee)
  return fee_;
}
inline void NEMSignTx_NEMProvisionNamespace::set_fee(::google::protobuf::uint64 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.fee)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition

// optional string name = 1;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
  return name_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name)
}

// optional string ticker = 2;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_ticker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_ticker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_ticker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticker();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::ticker() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
  return ticker_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_ticker(const ::std::string& value) {
  set_has_ticker();
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_ticker(::std::string&& value) {
  set_has_ticker();
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticker();
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_ticker(const char* value, size_t size) {
  set_has_ticker();
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_ticker() {
  set_has_ticker();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_ticker() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
  if (!has_ticker()) {
    return NULL;
  }
  clear_has_ticker();
  return ticker_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    set_has_ticker();
  } else {
    clear_has_ticker();
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker)
}

// optional string namespace = 3;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_namespace_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_namespace_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::namespace_() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
  return namespace__.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_namespace_(::std::string&& value) {
  set_has_namespace_();
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_namespace_() {
  set_has_namespace_();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_namespace_() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
  if (!has_namespace_()) {
    return NULL;
  }
  clear_has_namespace_();
  return namespace__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    set_has_namespace_();
  } else {
    clear_has_namespace_();
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace)
}

// optional string mosaic = 4;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_mosaic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_mosaic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_mosaic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_mosaic() {
  mosaic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mosaic();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mosaic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
  return mosaic_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_mosaic(const ::std::string& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_mosaic(::std::string&& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_mosaic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_mosaic(const char* value, size_t size) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_mosaic() {
  set_has_mosaic();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
  return mosaic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_mosaic() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
  if (!has_mosaic()) {
    return NULL;
  }
  clear_has_mosaic();
  return mosaic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_mosaic(::std::string* mosaic) {
  if (mosaic != NULL) {
    set_has_mosaic();
  } else {
    clear_has_mosaic();
  }
  mosaic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mosaic);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic)
}

// optional uint32 divisibility = 5;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_divisibility() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_divisibility() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_divisibility() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_divisibility() {
  divisibility_ = 0u;
  clear_has_divisibility();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::divisibility() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.divisibility)
  return divisibility_;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_divisibility(::google::protobuf::uint32 value) {
  set_has_divisibility();
  divisibility_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.divisibility)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_levy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_levy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_levy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_levy() {
  levy_ = 1;
  clear_has_levy();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::levy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy)
  return static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy >(levy_);
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy value) {
  assert(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(value));
  set_has_levy();
  levy_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy)
}

// optional uint64 fee = 7;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_fee() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_fee() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_fee() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_fee() {
  fee_ = GOOGLE_ULONGLONG(0);
  clear_has_fee();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.fee)
  return fee_;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_fee(::google::protobuf::uint64 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.fee)
}

// optional string levy_address = 8;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_levy_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_levy_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_levy_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_levy_address() {
  levy_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_levy_address();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::levy_address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
  return levy_address_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_address(const ::std::string& value) {
  set_has_levy_address();
  levy_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_address(::std::string&& value) {
  set_has_levy_address();
  levy_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_levy_address();
  levy_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_address(const char* value, size_t size) {
  set_has_levy_address();
  levy_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_levy_address() {
  set_has_levy_address();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
  return levy_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_levy_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
  if (!has_levy_address()) {
    return NULL;
  }
  clear_has_levy_address();
  return levy_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_levy_address(::std::string* levy_address) {
  if (levy_address != NULL) {
    set_has_levy_address();
  } else {
    clear_has_levy_address();
  }
  levy_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), levy_address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address)
}

// optional string levy_namespace = 9;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_levy_namespace() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_levy_namespace() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_levy_namespace() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_levy_namespace() {
  levy_namespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_levy_namespace();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::levy_namespace() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
  return levy_namespace_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_namespace(const ::std::string& value) {
  set_has_levy_namespace();
  levy_namespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_namespace(::std::string&& value) {
  set_has_levy_namespace();
  levy_namespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_namespace(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_levy_namespace();
  levy_namespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_namespace(const char* value, size_t size) {
  set_has_levy_namespace();
  levy_namespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_levy_namespace() {
  set_has_levy_namespace();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
  return levy_namespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_levy_namespace() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
  if (!has_levy_namespace()) {
    return NULL;
  }
  clear_has_levy_namespace();
  return levy_namespace_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_levy_namespace(::std::string* levy_namespace) {
  if (levy_namespace != NULL) {
    set_has_levy_namespace();
  } else {
    clear_has_levy_namespace();
  }
  levy_namespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), levy_namespace);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace)
}

// optional string levy_mosaic = 10;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_levy_mosaic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_levy_mosaic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_levy_mosaic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_levy_mosaic() {
  levy_mosaic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_levy_mosaic();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::levy_mosaic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
  return levy_mosaic_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_mosaic(const ::std::string& value) {
  set_has_levy_mosaic();
  levy_mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_mosaic(::std::string&& value) {
  set_has_levy_mosaic();
  levy_mosaic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_mosaic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_levy_mosaic();
  levy_mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_levy_mosaic(const char* value, size_t size) {
  set_has_levy_mosaic();
  levy_mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_levy_mosaic() {
  set_has_levy_mosaic();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
  return levy_mosaic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_levy_mosaic() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
  if (!has_levy_mosaic()) {
    return NULL;
  }
  clear_has_levy_mosaic();
  return levy_mosaic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_levy_mosaic(::std::string* levy_mosaic) {
  if (levy_mosaic != NULL) {
    set_has_levy_mosaic();
  } else {
    clear_has_levy_mosaic();
  }
  levy_mosaic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), levy_mosaic);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic)
}

// optional uint64 supply = 11;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_supply() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_supply() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_supply() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_supply() {
  supply_ = GOOGLE_ULONGLONG(0);
  clear_has_supply();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::supply() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.supply)
  return supply_;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_supply(::google::protobuf::uint64 value) {
  set_has_supply();
  supply_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.supply)
}

// optional bool mutable_supply = 12;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_mutable_supply() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_mutable_supply() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_mutable_supply() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_mutable_supply() {
  mutable_supply_ = false;
  clear_has_mutable_supply();
}
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_supply() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mutable_supply)
  return mutable_supply_;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_mutable_supply(bool value) {
  set_has_mutable_supply();
  mutable_supply_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mutable_supply)
}

// optional bool transferable = 13;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_transferable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_transferable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_transferable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_transferable() {
  transferable_ = false;
  clear_has_transferable();
}
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::transferable() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.transferable)
  return transferable_;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_transferable(bool value) {
  set_has_transferable();
  transferable_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.transferable)
}

// optional string description = 14;
inline bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::has_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_has_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_has_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::description() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
  return description_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
}
#endif
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::release_description() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description)
}

// repeated uint32 networks = 15;
inline int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::networks_size() const {
  return networks_.size();
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::clear_networks() {
  networks_.Clear();
}
inline ::google::protobuf::uint32 NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::networks(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.networks)
  return networks_.Get(index);
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::set_networks(int index, ::google::protobuf::uint32 value) {
  networks_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.networks)
}
inline void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::add_networks(::google::protobuf::uint32 value) {
  networks_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.networks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::networks() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.networks)
  return networks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::mutable_networks() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.networks)
  return &networks_;
}

// -------------------------------------------------------------------

// NEMSignTx_NEMMosaicCreation

// optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
inline bool NEMSignTx_NEMMosaicCreation::has_definition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation::set_has_definition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_has_definition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_definition() {
  if (definition_ != NULL) definition_->Clear();
  clear_has_definition();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& NEMSignTx_NEMMosaicCreation::_internal_definition() const {
  return *definition_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& NEMSignTx_NEMMosaicCreation::definition() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* p = definition_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.definition)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* NEMSignTx_NEMMosaicCreation::release_definition() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.definition)
  clear_has_definition();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* temp = definition_;
  definition_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* NEMSignTx_NEMMosaicCreation::mutable_definition() {
  set_has_definition();
  if (definition_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(GetArenaNoVirtual());
    definition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.definition)
  return definition_;
}
inline void NEMSignTx_NEMMosaicCreation::set_allocated_definition(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* definition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete definition_;
  }
  if (definition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      definition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, definition, submessage_arena);
    }
    set_has_definition();
  } else {
    clear_has_definition();
  }
  definition_ = definition;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.definition)
}

// optional string sink = 2;
inline bool NEMSignTx_NEMMosaicCreation::has_sink() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation::set_has_sink() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_has_sink() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_sink() {
  sink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sink();
}
inline const ::std::string& NEMSignTx_NEMMosaicCreation::sink() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
  return sink_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicCreation::set_sink(const ::std::string& value) {
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicCreation::set_sink(::std::string&& value) {
  set_has_sink();
  sink_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
}
#endif
inline void NEMSignTx_NEMMosaicCreation::set_sink(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
}
inline void NEMSignTx_NEMMosaicCreation::set_sink(const char* value, size_t size) {
  set_has_sink();
  sink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
}
inline ::std::string* NEMSignTx_NEMMosaicCreation::mutable_sink() {
  set_has_sink();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
  return sink_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicCreation::release_sink() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
  if (!has_sink()) {
    return NULL;
  }
  clear_has_sink();
  return sink_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicCreation::set_allocated_sink(::std::string* sink) {
  if (sink != NULL) {
    set_has_sink();
  } else {
    clear_has_sink();
  }
  sink_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sink);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink)
}

// optional uint64 fee = 3;
inline bool NEMSignTx_NEMMosaicCreation::has_fee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMMosaicCreation::set_has_fee() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_has_fee() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMMosaicCreation::clear_fee() {
  fee_ = GOOGLE_ULONGLONG(0);
  clear_has_fee();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMMosaicCreation::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.fee)
  return fee_;
}
inline void NEMSignTx_NEMMosaicCreation::set_fee(::google::protobuf::uint64 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.fee)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMMosaicSupplyChange

// optional string namespace = 1;
inline bool NEMSignTx_NEMMosaicSupplyChange::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_namespace_();
}
inline const ::std::string& NEMSignTx_NEMMosaicSupplyChange::namespace_() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
  return namespace__.GetNoArena();
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicSupplyChange::set_namespace_(::std::string&& value) {
  set_has_namespace_();
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
}
#endif
inline void NEMSignTx_NEMMosaicSupplyChange::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
}
inline ::std::string* NEMSignTx_NEMMosaicSupplyChange::mutable_namespace_() {
  set_has_namespace_();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicSupplyChange::release_namespace_() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
  if (!has_namespace_()) {
    return NULL;
  }
  clear_has_namespace_();
  return namespace__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    set_has_namespace_();
  } else {
    clear_has_namespace_();
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace)
}

// optional string mosaic = 2;
inline bool NEMSignTx_NEMMosaicSupplyChange::has_mosaic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_has_mosaic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_has_mosaic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_mosaic() {
  mosaic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mosaic();
}
inline const ::std::string& NEMSignTx_NEMMosaicSupplyChange::mosaic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
  return mosaic_.GetNoArena();
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_mosaic(const ::std::string& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
}
#if LANG_CXX11
inline void NEMSignTx_NEMMosaicSupplyChange::set_mosaic(::std::string&& value) {
  set_has_mosaic();
  mosaic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
}
#endif
inline void NEMSignTx_NEMMosaicSupplyChange::set_mosaic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_mosaic(const char* value, size_t size) {
  set_has_mosaic();
  mosaic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
}
inline ::std::string* NEMSignTx_NEMMosaicSupplyChange::mutable_mosaic() {
  set_has_mosaic();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
  return mosaic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMMosaicSupplyChange::release_mosaic() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
  if (!has_mosaic()) {
    return NULL;
  }
  clear_has_mosaic();
  return mosaic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_allocated_mosaic(::std::string* mosaic) {
  if (mosaic != NULL) {
    set_has_mosaic();
  } else {
    clear_has_mosaic();
  }
  mosaic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mosaic);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
inline bool NEMSignTx_NEMMosaicSupplyChange::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.type)
  return static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType >(type_);
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_type(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType value) {
  assert(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.type)
}

// optional uint64 delta = 4;
inline bool NEMSignTx_NEMMosaicSupplyChange::has_delta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_has_delta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_has_delta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx_NEMMosaicSupplyChange::clear_delta() {
  delta_ = GOOGLE_ULONGLONG(0);
  clear_has_delta();
}
inline ::google::protobuf::uint64 NEMSignTx_NEMMosaicSupplyChange::delta() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.delta)
  return delta_;
}
inline void NEMSignTx_NEMMosaicSupplyChange::set_delta(::google::protobuf::uint64 value) {
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.delta)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMAggregateModification_NEMCosignatoryModification

// optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
inline bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.type)
  return static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType >(type_);
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_type(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType value) {
  assert(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.type)
}

// optional bytes public_key = 2;
inline bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
  return public_key_.GetNoArena();
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
}
#if LANG_CXX11
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
}
#endif
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
}
inline ::std::string* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.public_key)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMAggregateModification

// repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
inline int NEMSignTx_NEMAggregateModification::modifications_size() const {
  return modifications_.size();
}
inline void NEMSignTx_NEMAggregateModification::clear_modifications() {
  modifications_.Clear();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* NEMSignTx_NEMAggregateModification::mutable_modifications(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications)
  return modifications_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >*
NEMSignTx_NEMAggregateModification::mutable_modifications() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications)
  return &modifications_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& NEMSignTx_NEMAggregateModification::modifications(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications)
  return modifications_.Get(index);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* NEMSignTx_NEMAggregateModification::add_modifications() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications)
  return modifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >&
NEMSignTx_NEMAggregateModification::modifications() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications)
  return modifications_;
}

// optional sint32 relative_change = 2;
inline bool NEMSignTx_NEMAggregateModification::has_relative_change() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMAggregateModification::set_has_relative_change() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMAggregateModification::clear_has_relative_change() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMAggregateModification::clear_relative_change() {
  relative_change_ = 0;
  clear_has_relative_change();
}
inline ::google::protobuf::int32 NEMSignTx_NEMAggregateModification::relative_change() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.relative_change)
  return relative_change_;
}
inline void NEMSignTx_NEMAggregateModification::set_relative_change(::google::protobuf::int32 value) {
  set_has_relative_change();
  relative_change_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.relative_change)
}

// -------------------------------------------------------------------

// NEMSignTx_NEMImportanceTransfer

// optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
inline bool NEMSignTx_NEMImportanceTransfer::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx_NEMImportanceTransfer::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx_NEMImportanceTransfer::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx_NEMImportanceTransfer::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer::mode() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.mode)
  return static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode >(mode_);
}
inline void NEMSignTx_NEMImportanceTransfer::set_mode(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode value) {
  assert(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.mode)
}

// optional bytes public_key = 2;
inline bool NEMSignTx_NEMImportanceTransfer::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx_NEMImportanceTransfer::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx_NEMImportanceTransfer::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx_NEMImportanceTransfer::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& NEMSignTx_NEMImportanceTransfer::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
  return public_key_.GetNoArena();
}
inline void NEMSignTx_NEMImportanceTransfer::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
}
#if LANG_CXX11
inline void NEMSignTx_NEMImportanceTransfer::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
}
#endif
inline void NEMSignTx_NEMImportanceTransfer::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
}
inline void NEMSignTx_NEMImportanceTransfer::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
}
inline ::std::string* NEMSignTx_NEMImportanceTransfer::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignTx_NEMImportanceTransfer::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignTx_NEMImportanceTransfer::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.public_key)
}

// -------------------------------------------------------------------

// NEMSignTx

// optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
inline bool NEMSignTx::has_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignTx::set_has_transaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignTx::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignTx::clear_transaction() {
  if (transaction_ != NULL) transaction_->Clear();
  clear_has_transaction();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& NEMSignTx::_internal_transaction() const {
  return *transaction_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& NEMSignTx::transaction() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* p = transaction_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMTransactionCommon_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* NEMSignTx::release_transaction() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.transaction)
  clear_has_transaction();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* NEMSignTx::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.transaction)
  return transaction_;
}
inline void NEMSignTx::set_allocated_transaction(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.transaction)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
inline bool NEMSignTx::has_multisig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignTx::set_has_multisig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignTx::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignTx::clear_multisig() {
  if (multisig_ != NULL) multisig_->Clear();
  clear_has_multisig();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& NEMSignTx::_internal_multisig() const {
  return *multisig_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& NEMSignTx::multisig() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* p = multisig_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.multisig)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMTransactionCommon_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* NEMSignTx::release_multisig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.multisig)
  clear_has_multisig();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* NEMSignTx::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon>(GetArenaNoVirtual());
    multisig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.multisig)
  return multisig_;
}
inline void NEMSignTx::set_allocated_multisig(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* multisig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete multisig_;
  }
  if (multisig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      multisig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig, submessage_arena);
    }
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  multisig_ = multisig;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.multisig)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
inline bool NEMSignTx::has_transfer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMSignTx::set_has_transfer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMSignTx::clear_has_transfer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMSignTx::clear_transfer() {
  if (transfer_ != NULL) transfer_->Clear();
  clear_has_transfer();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer& NEMSignTx::_internal_transfer() const {
  return *transfer_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer& NEMSignTx::transfer() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* p = transfer_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.transfer)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMTransfer_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* NEMSignTx::release_transfer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.transfer)
  clear_has_transfer();
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* temp = transfer_;
  transfer_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* NEMSignTx::mutable_transfer() {
  set_has_transfer();
  if (transfer_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMTransfer>(GetArenaNoVirtual());
    transfer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.transfer)
  return transfer_;
}
inline void NEMSignTx::set_allocated_transfer(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* transfer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transfer_;
  }
  if (transfer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transfer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    set_has_transfer();
  } else {
    clear_has_transfer();
  }
  transfer_ = transfer;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.transfer)
}

// optional bool cosigning = 4;
inline bool NEMSignTx::has_cosigning() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NEMSignTx::set_has_cosigning() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NEMSignTx::clear_has_cosigning() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NEMSignTx::clear_cosigning() {
  cosigning_ = false;
  clear_has_cosigning();
}
inline bool NEMSignTx::cosigning() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.cosigning)
  return cosigning_;
}
inline void NEMSignTx::set_cosigning(bool value) {
  set_has_cosigning();
  cosigning_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignTx.cosigning)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
inline bool NEMSignTx::has_provision_namespace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NEMSignTx::set_has_provision_namespace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NEMSignTx::clear_has_provision_namespace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NEMSignTx::clear_provision_namespace() {
  if (provision_namespace_ != NULL) provision_namespace_->Clear();
  clear_has_provision_namespace();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace& NEMSignTx::_internal_provision_namespace() const {
  return *provision_namespace_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace& NEMSignTx::provision_namespace() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* p = provision_namespace_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.provision_namespace)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMProvisionNamespace_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* NEMSignTx::release_provision_namespace() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.provision_namespace)
  clear_has_provision_namespace();
  ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* temp = provision_namespace_;
  provision_namespace_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* NEMSignTx::mutable_provision_namespace() {
  set_has_provision_namespace();
  if (provision_namespace_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace>(GetArenaNoVirtual());
    provision_namespace_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.provision_namespace)
  return provision_namespace_;
}
inline void NEMSignTx::set_allocated_provision_namespace(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* provision_namespace) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete provision_namespace_;
  }
  if (provision_namespace) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      provision_namespace = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, provision_namespace, submessage_arena);
    }
    set_has_provision_namespace();
  } else {
    clear_has_provision_namespace();
  }
  provision_namespace_ = provision_namespace;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.provision_namespace)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
inline bool NEMSignTx::has_mosaic_creation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NEMSignTx::set_has_mosaic_creation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NEMSignTx::clear_has_mosaic_creation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NEMSignTx::clear_mosaic_creation() {
  if (mosaic_creation_ != NULL) mosaic_creation_->Clear();
  clear_has_mosaic_creation();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation& NEMSignTx::_internal_mosaic_creation() const {
  return *mosaic_creation_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation& NEMSignTx::mosaic_creation() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* p = mosaic_creation_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.mosaic_creation)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* NEMSignTx::release_mosaic_creation() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.mosaic_creation)
  clear_has_mosaic_creation();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* temp = mosaic_creation_;
  mosaic_creation_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* NEMSignTx::mutable_mosaic_creation() {
  set_has_mosaic_creation();
  if (mosaic_creation_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation>(GetArenaNoVirtual());
    mosaic_creation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.mosaic_creation)
  return mosaic_creation_;
}
inline void NEMSignTx::set_allocated_mosaic_creation(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* mosaic_creation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mosaic_creation_;
  }
  if (mosaic_creation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mosaic_creation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mosaic_creation, submessage_arena);
    }
    set_has_mosaic_creation();
  } else {
    clear_has_mosaic_creation();
  }
  mosaic_creation_ = mosaic_creation;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.mosaic_creation)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
inline bool NEMSignTx::has_supply_change() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NEMSignTx::set_has_supply_change() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NEMSignTx::clear_has_supply_change() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NEMSignTx::clear_supply_change() {
  if (supply_change_ != NULL) supply_change_->Clear();
  clear_has_supply_change();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange& NEMSignTx::_internal_supply_change() const {
  return *supply_change_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange& NEMSignTx::supply_change() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* p = supply_change_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.supply_change)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicSupplyChange_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* NEMSignTx::release_supply_change() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.supply_change)
  clear_has_supply_change();
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* temp = supply_change_;
  supply_change_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* NEMSignTx::mutable_supply_change() {
  set_has_supply_change();
  if (supply_change_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange>(GetArenaNoVirtual());
    supply_change_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.supply_change)
  return supply_change_;
}
inline void NEMSignTx::set_allocated_supply_change(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* supply_change) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete supply_change_;
  }
  if (supply_change) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      supply_change = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supply_change, submessage_arena);
    }
    set_has_supply_change();
  } else {
    clear_has_supply_change();
  }
  supply_change_ = supply_change;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.supply_change)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
inline bool NEMSignTx::has_aggregate_modification() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NEMSignTx::set_has_aggregate_modification() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NEMSignTx::clear_has_aggregate_modification() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NEMSignTx::clear_aggregate_modification() {
  if (aggregate_modification_ != NULL) aggregate_modification_->Clear();
  clear_has_aggregate_modification();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification& NEMSignTx::_internal_aggregate_modification() const {
  return *aggregate_modification_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification& NEMSignTx::aggregate_modification() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* p = aggregate_modification_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.aggregate_modification)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMAggregateModification_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* NEMSignTx::release_aggregate_modification() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.aggregate_modification)
  clear_has_aggregate_modification();
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* temp = aggregate_modification_;
  aggregate_modification_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* NEMSignTx::mutable_aggregate_modification() {
  set_has_aggregate_modification();
  if (aggregate_modification_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification>(GetArenaNoVirtual());
    aggregate_modification_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.aggregate_modification)
  return aggregate_modification_;
}
inline void NEMSignTx::set_allocated_aggregate_modification(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* aggregate_modification) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aggregate_modification_;
  }
  if (aggregate_modification) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aggregate_modification = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aggregate_modification, submessage_arena);
    }
    set_has_aggregate_modification();
  } else {
    clear_has_aggregate_modification();
  }
  aggregate_modification_ = aggregate_modification;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.aggregate_modification)
}

// optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
inline bool NEMSignTx::has_importance_transfer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NEMSignTx::set_has_importance_transfer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NEMSignTx::clear_has_importance_transfer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NEMSignTx::clear_importance_transfer() {
  if (importance_transfer_ != NULL) importance_transfer_->Clear();
  clear_has_importance_transfer();
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer& NEMSignTx::_internal_importance_transfer() const {
  return *importance_transfer_;
}
inline const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer& NEMSignTx::importance_transfer() const {
  const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* p = importance_transfer_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignTx.importance_transfer)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer*>(
      &::hw::trezor::messages::nem::_NEMSignTx_NEMImportanceTransfer_default_instance_);
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* NEMSignTx::release_importance_transfer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignTx.importance_transfer)
  clear_has_importance_transfer();
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* temp = importance_transfer_;
  importance_transfer_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* NEMSignTx::mutable_importance_transfer() {
  set_has_importance_transfer();
  if (importance_transfer_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer>(GetArenaNoVirtual());
    importance_transfer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignTx.importance_transfer)
  return importance_transfer_;
}
inline void NEMSignTx::set_allocated_importance_transfer(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* importance_transfer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete importance_transfer_;
  }
  if (importance_transfer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      importance_transfer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, importance_transfer, submessage_arena);
    }
    set_has_importance_transfer();
  } else {
    clear_has_importance_transfer();
  }
  importance_transfer_ = importance_transfer;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignTx.importance_transfer)
}

// -------------------------------------------------------------------

// NEMSignedTx

// optional bytes data = 1;
inline bool NEMSignedTx::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMSignedTx::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMSignedTx::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMSignedTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& NEMSignedTx::data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignedTx.data)
  return data_.GetNoArena();
}
inline void NEMSignedTx::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignedTx.data)
}
#if LANG_CXX11
inline void NEMSignedTx::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignedTx.data)
}
#endif
inline void NEMSignedTx::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignedTx.data)
}
inline void NEMSignedTx::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignedTx.data)
}
inline ::std::string* NEMSignedTx::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignedTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignedTx::release_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignedTx.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignedTx::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignedTx.data)
}

// optional bytes signature = 2;
inline bool NEMSignedTx::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMSignedTx::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMSignedTx::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMSignedTx::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& NEMSignedTx::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMSignedTx.signature)
  return signature_.GetNoArena();
}
inline void NEMSignedTx::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMSignedTx.signature)
}
#if LANG_CXX11
inline void NEMSignedTx::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMSignedTx.signature)
}
#endif
inline void NEMSignedTx::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMSignedTx.signature)
}
inline void NEMSignedTx::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMSignedTx.signature)
}
inline ::std::string* NEMSignedTx::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMSignedTx.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMSignedTx::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMSignedTx.signature)
  if (!has_signature()) {
    return NULL;
  }
  clear_has_signature();
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMSignedTx::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMSignedTx.signature)
}

// -------------------------------------------------------------------

// NEMDecryptMessage

// repeated uint32 address_n = 1;
inline int NEMDecryptMessage::address_n_size() const {
  return address_n_.size();
}
inline void NEMDecryptMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 NEMDecryptMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMDecryptMessage.address_n)
  return address_n_.Get(index);
}
inline void NEMDecryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMDecryptMessage.address_n)
}
inline void NEMDecryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.nem.NEMDecryptMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NEMDecryptMessage::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.nem.NEMDecryptMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NEMDecryptMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.nem.NEMDecryptMessage.address_n)
  return &address_n_;
}

// optional uint32 network = 2;
inline bool NEMDecryptMessage::has_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NEMDecryptMessage::set_has_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NEMDecryptMessage::clear_has_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NEMDecryptMessage::clear_network() {
  network_ = 0u;
  clear_has_network();
}
inline ::google::protobuf::uint32 NEMDecryptMessage::network() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMDecryptMessage.network)
  return network_;
}
inline void NEMDecryptMessage::set_network(::google::protobuf::uint32 value) {
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMDecryptMessage.network)
}

// optional bytes public_key = 3;
inline bool NEMDecryptMessage::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMDecryptMessage::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMDecryptMessage::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMDecryptMessage::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& NEMDecryptMessage::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
  return public_key_.GetNoArena();
}
inline void NEMDecryptMessage::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
}
#if LANG_CXX11
inline void NEMDecryptMessage::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
}
#endif
inline void NEMDecryptMessage::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
}
inline void NEMDecryptMessage::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
}
inline ::std::string* NEMDecryptMessage::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMDecryptMessage::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMDecryptMessage::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMDecryptMessage.public_key)
}

// optional bytes payload = 4;
inline bool NEMDecryptMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NEMDecryptMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NEMDecryptMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NEMDecryptMessage::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& NEMDecryptMessage::payload() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMDecryptMessage.payload)
  return payload_.GetNoArena();
}
inline void NEMDecryptMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMDecryptMessage.payload)
}
#if LANG_CXX11
inline void NEMDecryptMessage::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMDecryptMessage.payload)
}
#endif
inline void NEMDecryptMessage::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMDecryptMessage.payload)
}
inline void NEMDecryptMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMDecryptMessage.payload)
}
inline ::std::string* NEMDecryptMessage::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMDecryptMessage.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMDecryptMessage::release_payload() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMDecryptMessage.payload)
  if (!has_payload()) {
    return NULL;
  }
  clear_has_payload();
  return payload_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMDecryptMessage::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMDecryptMessage.payload)
}

// -------------------------------------------------------------------

// NEMDecryptedMessage

// optional bytes payload = 1;
inline bool NEMDecryptedMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NEMDecryptedMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NEMDecryptedMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NEMDecryptedMessage::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& NEMDecryptedMessage::payload() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
  return payload_.GetNoArena();
}
inline void NEMDecryptedMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
}
#if LANG_CXX11
inline void NEMDecryptedMessage::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
}
#endif
inline void NEMDecryptedMessage::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
}
inline void NEMDecryptedMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
}
inline ::std::string* NEMDecryptedMessage::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NEMDecryptedMessage::release_payload() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
  if (!has_payload()) {
    return NULL;
  }
  clear_has_payload();
  return payload_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NEMDecryptedMessage::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.nem.NEMDecryptedMessage.payload)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nem
}  // namespace messages
}  // namespace trezor
}  // namespace hw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy>() {
  return ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType>() {
  return ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType>() {
  return ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode>() {
  return ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2dnem_2eproto
