// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-debug.proto

#ifndef PROTOBUF_INCLUDED_messages_2ddebug_2eproto
#define PROTOBUF_INCLUDED_messages_2ddebug_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2ddebug_2eproto 

namespace protobuf_messages_2ddebug_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2ddebug_2eproto
namespace hw {
namespace trezor {
namespace messages {
namespace debug {
class DebugLinkDecision;
class DebugLinkDecisionDefaultTypeInternal;
extern DebugLinkDecisionDefaultTypeInternal _DebugLinkDecision_default_instance_;
class DebugLinkFlashErase;
class DebugLinkFlashEraseDefaultTypeInternal;
extern DebugLinkFlashEraseDefaultTypeInternal _DebugLinkFlashErase_default_instance_;
class DebugLinkGetState;
class DebugLinkGetStateDefaultTypeInternal;
extern DebugLinkGetStateDefaultTypeInternal _DebugLinkGetState_default_instance_;
class DebugLinkLog;
class DebugLinkLogDefaultTypeInternal;
extern DebugLinkLogDefaultTypeInternal _DebugLinkLog_default_instance_;
class DebugLinkMemory;
class DebugLinkMemoryDefaultTypeInternal;
extern DebugLinkMemoryDefaultTypeInternal _DebugLinkMemory_default_instance_;
class DebugLinkMemoryRead;
class DebugLinkMemoryReadDefaultTypeInternal;
extern DebugLinkMemoryReadDefaultTypeInternal _DebugLinkMemoryRead_default_instance_;
class DebugLinkMemoryWrite;
class DebugLinkMemoryWriteDefaultTypeInternal;
extern DebugLinkMemoryWriteDefaultTypeInternal _DebugLinkMemoryWrite_default_instance_;
class DebugLinkState;
class DebugLinkStateDefaultTypeInternal;
extern DebugLinkStateDefaultTypeInternal _DebugLinkState_default_instance_;
class DebugLinkStop;
class DebugLinkStopDefaultTypeInternal;
extern DebugLinkStopDefaultTypeInternal _DebugLinkStop_default_instance_;
}  // namespace debug
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::debug::DebugLinkDecision* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkDecision>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkFlashErase* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkFlashErase>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkGetState* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkGetState>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkLog* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkLog>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemory* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemory>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemoryRead* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemoryRead>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemoryWrite* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemoryWrite>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkState* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkState>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkStop* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkStop>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace debug {

// ===================================================================

class DebugLinkDecision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkDecision) */ {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();

  DebugLinkDecision(const DebugLinkDecision& from);

  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkDecision(DebugLinkDecision&& from) noexcept
    : DebugLinkDecision() {
    *this = ::std::move(from);
  }

  inline DebugLinkDecision& operator=(DebugLinkDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkDecision* internal_default_instance() {
    return reinterpret_cast<const DebugLinkDecision*>(
               &_DebugLinkDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DebugLinkDecision* other);
  friend void swap(DebugLinkDecision& a, DebugLinkDecision& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkDecision* New() const final {
    return CreateMaybeMessage<DebugLinkDecision>(NULL);
  }

  DebugLinkDecision* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkDecision>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkDecision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string input = 3;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  #if LANG_CXX11
  void set_input(::std::string&& value);
  #endif
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // optional bool yes_no = 1;
  bool has_yes_no() const;
  void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  bool yes_no() const;
  void set_yes_no(bool value);

  // optional bool up_down = 2;
  bool has_up_down() const;
  void clear_up_down();
  static const int kUpDownFieldNumber = 2;
  bool up_down() const;
  void set_up_down(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkDecision)
 private:
  void set_has_yes_no();
  void clear_has_yes_no();
  void set_has_up_down();
  void clear_has_up_down();
  void set_has_input();
  void clear_has_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  bool yes_no_;
  bool up_down_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkGetState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkGetState) */ {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();

  DebugLinkGetState(const DebugLinkGetState& from);

  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkGetState(DebugLinkGetState&& from) noexcept
    : DebugLinkGetState() {
    *this = ::std::move(from);
  }

  inline DebugLinkGetState& operator=(DebugLinkGetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkGetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkGetState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkGetState*>(
               &_DebugLinkGetState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DebugLinkGetState* other);
  friend void swap(DebugLinkGetState& a, DebugLinkGetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkGetState* New() const final {
    return CreateMaybeMessage<DebugLinkGetState>(NULL);
  }

  DebugLinkGetState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkGetState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkGetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkGetState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkState) */ {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();

  DebugLinkState(const DebugLinkState& from);

  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkState(DebugLinkState&& from) noexcept
    : DebugLinkState() {
    *this = ::std::move(from);
  }

  inline DebugLinkState& operator=(DebugLinkState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkState*>(
               &_DebugLinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DebugLinkState* other);
  friend void swap(DebugLinkState& a, DebugLinkState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkState* New() const final {
    return CreateMaybeMessage<DebugLinkState>(NULL);
  }

  DebugLinkState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes layout = 1;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 1;
  const ::std::string& layout() const;
  void set_layout(const ::std::string& value);
  #if LANG_CXX11
  void set_layout(::std::string&& value);
  #endif
  void set_layout(const char* value);
  void set_layout(const void* value, size_t size);
  ::std::string* mutable_layout();
  ::std::string* release_layout();
  void set_allocated_layout(::std::string* layout);

  // optional string pin = 2;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // optional string matrix = 3;
  bool has_matrix() const;
  void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  const ::std::string& matrix() const;
  void set_matrix(const ::std::string& value);
  #if LANG_CXX11
  void set_matrix(::std::string&& value);
  #endif
  void set_matrix(const char* value);
  void set_matrix(const char* value, size_t size);
  ::std::string* mutable_matrix();
  ::std::string* release_matrix();
  void set_allocated_matrix(::std::string* matrix);

  // optional string mnemonic = 4;
  bool has_mnemonic() const;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 4;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  #if LANG_CXX11
  void set_mnemonic(::std::string&& value);
  #endif
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // optional string reset_word = 7;
  bool has_reset_word() const;
  void clear_reset_word();
  static const int kResetWordFieldNumber = 7;
  const ::std::string& reset_word() const;
  void set_reset_word(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_word(::std::string&& value);
  #endif
  void set_reset_word(const char* value);
  void set_reset_word(const char* value, size_t size);
  ::std::string* mutable_reset_word();
  ::std::string* release_reset_word();
  void set_allocated_reset_word(::std::string* reset_word);

  // optional bytes reset_entropy = 8;
  bool has_reset_entropy() const;
  void clear_reset_entropy();
  static const int kResetEntropyFieldNumber = 8;
  const ::std::string& reset_entropy() const;
  void set_reset_entropy(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_entropy(::std::string&& value);
  #endif
  void set_reset_entropy(const char* value);
  void set_reset_entropy(const void* value, size_t size);
  ::std::string* mutable_reset_entropy();
  ::std::string* release_reset_entropy();
  void set_allocated_reset_entropy(::std::string* reset_entropy);

  // optional string recovery_fake_word = 9;
  bool has_recovery_fake_word() const;
  void clear_recovery_fake_word();
  static const int kRecoveryFakeWordFieldNumber = 9;
  const ::std::string& recovery_fake_word() const;
  void set_recovery_fake_word(const ::std::string& value);
  #if LANG_CXX11
  void set_recovery_fake_word(::std::string&& value);
  #endif
  void set_recovery_fake_word(const char* value);
  void set_recovery_fake_word(const char* value, size_t size);
  ::std::string* mutable_recovery_fake_word();
  ::std::string* release_recovery_fake_word();
  void set_allocated_recovery_fake_word(::std::string* recovery_fake_word);

  // optional .hw.trezor.messages.common.HDNodeType node = 5;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 5;
  private:
  const ::hw::trezor::messages::common::HDNodeType& _internal_node() const;
  public:
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // optional bool passphrase_protection = 6;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 6;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional uint32 recovery_word_pos = 10;
  bool has_recovery_word_pos() const;
  void clear_recovery_word_pos();
  static const int kRecoveryWordPosFieldNumber = 10;
  ::google::protobuf::uint32 recovery_word_pos() const;
  void set_recovery_word_pos(::google::protobuf::uint32 value);

  // optional uint32 reset_word_pos = 11;
  bool has_reset_word_pos() const;
  void clear_reset_word_pos();
  static const int kResetWordPosFieldNumber = 11;
  ::google::protobuf::uint32 reset_word_pos() const;
  void set_reset_word_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkState)
 private:
  void set_has_layout();
  void clear_has_layout();
  void set_has_pin();
  void clear_has_pin();
  void set_has_matrix();
  void clear_has_matrix();
  void set_has_mnemonic();
  void clear_has_mnemonic();
  void set_has_node();
  void clear_has_node();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_reset_word();
  void clear_has_reset_word();
  void set_has_reset_entropy();
  void clear_has_reset_entropy();
  void set_has_recovery_fake_word();
  void clear_has_recovery_fake_word();
  void set_has_recovery_word_pos();
  void clear_has_recovery_word_pos();
  void set_has_reset_word_pos();
  void clear_has_reset_word_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr layout_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  ::google::protobuf::internal::ArenaStringPtr matrix_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::internal::ArenaStringPtr reset_word_;
  ::google::protobuf::internal::ArenaStringPtr reset_entropy_;
  ::google::protobuf::internal::ArenaStringPtr recovery_fake_word_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  bool passphrase_protection_;
  ::google::protobuf::uint32 recovery_word_pos_;
  ::google::protobuf::uint32 reset_word_pos_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkStop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkStop) */ {
 public:
  DebugLinkStop();
  virtual ~DebugLinkStop();

  DebugLinkStop(const DebugLinkStop& from);

  inline DebugLinkStop& operator=(const DebugLinkStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkStop(DebugLinkStop&& from) noexcept
    : DebugLinkStop() {
    *this = ::std::move(from);
  }

  inline DebugLinkStop& operator=(DebugLinkStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkStop* internal_default_instance() {
    return reinterpret_cast<const DebugLinkStop*>(
               &_DebugLinkStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DebugLinkStop* other);
  friend void swap(DebugLinkStop& a, DebugLinkStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkStop* New() const final {
    return CreateMaybeMessage<DebugLinkStop>(NULL);
  }

  DebugLinkStop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkStop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkStop& from);
  void MergeFrom(const DebugLinkStop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkStop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkLog) */ {
 public:
  DebugLinkLog();
  virtual ~DebugLinkLog();

  DebugLinkLog(const DebugLinkLog& from);

  inline DebugLinkLog& operator=(const DebugLinkLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkLog(DebugLinkLog&& from) noexcept
    : DebugLinkLog() {
    *this = ::std::move(from);
  }

  inline DebugLinkLog& operator=(DebugLinkLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkLog* internal_default_instance() {
    return reinterpret_cast<const DebugLinkLog*>(
               &_DebugLinkLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DebugLinkLog* other);
  friend void swap(DebugLinkLog& a, DebugLinkLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkLog* New() const final {
    return CreateMaybeMessage<DebugLinkLog>(NULL);
  }

  DebugLinkLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkLog& from);
  void MergeFrom(const DebugLinkLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 2;
  bool has_bucket() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 2;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkLog)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_bucket();
  void clear_has_bucket();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 level_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemoryRead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemoryRead) */ {
 public:
  DebugLinkMemoryRead();
  virtual ~DebugLinkMemoryRead();

  DebugLinkMemoryRead(const DebugLinkMemoryRead& from);

  inline DebugLinkMemoryRead& operator=(const DebugLinkMemoryRead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemoryRead(DebugLinkMemoryRead&& from) noexcept
    : DebugLinkMemoryRead() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemoryRead& operator=(DebugLinkMemoryRead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemoryRead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemoryRead* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryRead*>(
               &_DebugLinkMemoryRead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DebugLinkMemoryRead* other);
  friend void swap(DebugLinkMemoryRead& a, DebugLinkMemoryRead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryRead* New() const final {
    return CreateMaybeMessage<DebugLinkMemoryRead>(NULL);
  }

  DebugLinkMemoryRead* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemoryRead>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemoryRead& from);
  void MergeFrom(const DebugLinkMemoryRead& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemoryRead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional uint32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemoryRead)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_length();
  void clear_has_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 length_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemory) */ {
 public:
  DebugLinkMemory();
  virtual ~DebugLinkMemory();

  DebugLinkMemory(const DebugLinkMemory& from);

  inline DebugLinkMemory& operator=(const DebugLinkMemory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemory(DebugLinkMemory&& from) noexcept
    : DebugLinkMemory() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemory& operator=(DebugLinkMemory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemory* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemory*>(
               &_DebugLinkMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DebugLinkMemory* other);
  friend void swap(DebugLinkMemory& a, DebugLinkMemory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemory* New() const final {
    return CreateMaybeMessage<DebugLinkMemory>(NULL);
  }

  DebugLinkMemory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemory& from);
  void MergeFrom(const DebugLinkMemory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 1;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 1;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemory)
 private:
  void set_has_memory();
  void clear_has_memory();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemoryWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemoryWrite) */ {
 public:
  DebugLinkMemoryWrite();
  virtual ~DebugLinkMemoryWrite();

  DebugLinkMemoryWrite(const DebugLinkMemoryWrite& from);

  inline DebugLinkMemoryWrite& operator=(const DebugLinkMemoryWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemoryWrite(DebugLinkMemoryWrite&& from) noexcept
    : DebugLinkMemoryWrite() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemoryWrite& operator=(DebugLinkMemoryWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemoryWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemoryWrite* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryWrite*>(
               &_DebugLinkMemoryWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DebugLinkMemoryWrite* other);
  friend void swap(DebugLinkMemoryWrite& a, DebugLinkMemoryWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryWrite* New() const final {
    return CreateMaybeMessage<DebugLinkMemoryWrite>(NULL);
  }

  DebugLinkMemoryWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemoryWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemoryWrite& from);
  void MergeFrom(const DebugLinkMemoryWrite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemoryWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 2;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional bool flash = 3;
  bool has_flash() const;
  void clear_flash();
  static const int kFlashFieldNumber = 3;
  bool flash() const;
  void set_flash(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemoryWrite)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_memory();
  void clear_has_memory();
  void set_has_flash();
  void clear_has_flash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  ::google::protobuf::uint32 address_;
  bool flash_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkFlashErase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkFlashErase) */ {
 public:
  DebugLinkFlashErase();
  virtual ~DebugLinkFlashErase();

  DebugLinkFlashErase(const DebugLinkFlashErase& from);

  inline DebugLinkFlashErase& operator=(const DebugLinkFlashErase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkFlashErase(DebugLinkFlashErase&& from) noexcept
    : DebugLinkFlashErase() {
    *this = ::std::move(from);
  }

  inline DebugLinkFlashErase& operator=(DebugLinkFlashErase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkFlashErase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkFlashErase* internal_default_instance() {
    return reinterpret_cast<const DebugLinkFlashErase*>(
               &_DebugLinkFlashErase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DebugLinkFlashErase* other);
  friend void swap(DebugLinkFlashErase& a, DebugLinkFlashErase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkFlashErase* New() const final {
    return CreateMaybeMessage<DebugLinkFlashErase>(NULL);
  }

  DebugLinkFlashErase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkFlashErase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkFlashErase& from);
  void MergeFrom(const DebugLinkFlashErase& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkFlashErase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sector = 1;
  bool has_sector() const;
  void clear_sector();
  static const int kSectorFieldNumber = 1;
  ::google::protobuf::uint32 sector() const;
  void set_sector(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkFlashErase)
 private:
  void set_has_sector();
  void clear_has_sector();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sector_;
  friend struct ::protobuf_messages_2ddebug_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugLinkDecision

// optional bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
inline bool DebugLinkDecision::yes_no() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.yes_no)
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.yes_no)
}

// optional bool up_down = 2;
inline bool DebugLinkDecision::has_up_down() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkDecision::set_has_up_down() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkDecision::clear_has_up_down() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkDecision::clear_up_down() {
  up_down_ = false;
  clear_has_up_down();
}
inline bool DebugLinkDecision::up_down() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.up_down)
  return up_down_;
}
inline void DebugLinkDecision::set_up_down(bool value) {
  set_has_up_down();
  up_down_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.up_down)
}

// optional string input = 3;
inline bool DebugLinkDecision::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkDecision::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkDecision::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input();
}
inline const ::std::string& DebugLinkDecision::input() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.input)
  return input_.GetNoArena();
}
inline void DebugLinkDecision::set_input(const ::std::string& value) {
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.input)
}
#if LANG_CXX11
inline void DebugLinkDecision::set_input(::std::string&& value) {
  set_has_input();
  input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkDecision.input)
}
#endif
inline void DebugLinkDecision::set_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkDecision.input)
}
inline void DebugLinkDecision::set_input(const char* value, size_t size) {
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkDecision.input)
}
inline ::std::string* DebugLinkDecision::mutable_input() {
  set_has_input();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkDecision.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkDecision::release_input() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkDecision.input)
  if (!has_input()) {
    return NULL;
  }
  clear_has_input();
  return input_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkDecision::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    set_has_input();
  } else {
    clear_has_input();
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkDecision.input)
}

// -------------------------------------------------------------------

// DebugLinkGetState

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkState::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layout();
}
inline const ::std::string& DebugLinkState::layout() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.layout)
  return layout_.GetNoArena();
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.layout)
}
#if LANG_CXX11
inline void DebugLinkState::set_layout(::std::string&& value) {
  set_has_layout();
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.layout)
}
#endif
inline void DebugLinkState::set_layout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.layout)
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.layout)
}
inline ::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_layout() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.layout)
  if (!has_layout()) {
    return NULL;
  }
  clear_has_layout();
  return layout_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout != NULL) {
    set_has_layout();
  } else {
    clear_has_layout();
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.layout)
}

// optional string pin = 2;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkState::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& DebugLinkState::pin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.pin)
  return pin_.GetNoArena();
}
inline void DebugLinkState::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.pin)
}
#if LANG_CXX11
inline void DebugLinkState::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.pin)
}
#endif
inline void DebugLinkState::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.pin)
}
inline void DebugLinkState::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.pin)
}
inline ::std::string* DebugLinkState::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_pin() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.pin)
  if (!has_pin()) {
    return NULL;
  }
  clear_has_pin();
  return pin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.pin)
}

// optional string matrix = 3;
inline bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkState::clear_matrix() {
  matrix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_matrix();
}
inline const ::std::string& DebugLinkState::matrix() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.matrix)
  return matrix_.GetNoArena();
}
inline void DebugLinkState::set_matrix(const ::std::string& value) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.matrix)
}
#if LANG_CXX11
inline void DebugLinkState::set_matrix(::std::string&& value) {
  set_has_matrix();
  matrix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.matrix)
}
#endif
inline void DebugLinkState::set_matrix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.matrix)
}
inline void DebugLinkState::set_matrix(const char* value, size_t size) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.matrix)
}
inline ::std::string* DebugLinkState::mutable_matrix() {
  set_has_matrix();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.matrix)
  return matrix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_matrix() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.matrix)
  if (!has_matrix()) {
    return NULL;
  }
  clear_has_matrix();
  return matrix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix != NULL) {
    set_has_matrix();
  } else {
    clear_has_matrix();
  }
  matrix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matrix);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.matrix)
}

// optional string mnemonic = 4;
inline bool DebugLinkState::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkState::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkState::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mnemonic();
}
inline const ::std::string& DebugLinkState::mnemonic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.mnemonic)
  return mnemonic_.GetNoArena();
}
inline void DebugLinkState::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.mnemonic)
}
#if LANG_CXX11
inline void DebugLinkState::set_mnemonic(::std::string&& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.mnemonic)
}
#endif
inline void DebugLinkState::set_mnemonic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.mnemonic)
}
inline void DebugLinkState::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.mnemonic)
}
inline ::std::string* DebugLinkState::mutable_mnemonic() {
  set_has_mnemonic();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_mnemonic() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.mnemonic)
  if (!has_mnemonic()) {
    return NULL;
  }
  clear_has_mnemonic();
  return mnemonic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    set_has_mnemonic();
  } else {
    clear_has_mnemonic();
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.mnemonic)
}

// optional .hw.trezor.messages.common.HDNodeType node = 5;
inline bool DebugLinkState::has_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DebugLinkState::set_has_node() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DebugLinkState::clear_has_node() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::hw::trezor::messages::common::HDNodeType& DebugLinkState::_internal_node() const {
  return *node_;
}
inline const ::hw::trezor::messages::common::HDNodeType& DebugLinkState::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.node)
  return p != NULL ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* DebugLinkState::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.node)
  clear_has_node();
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* DebugLinkState::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.node)
  return node_;
}
inline void DebugLinkState::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    set_has_node();
  } else {
    clear_has_node();
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.node)
}

// optional bool passphrase_protection = 6;
inline bool DebugLinkState::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DebugLinkState::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DebugLinkState::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DebugLinkState::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool DebugLinkState::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.passphrase_protection)
  return passphrase_protection_;
}
inline void DebugLinkState::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.passphrase_protection)
}

// optional string reset_word = 7;
inline bool DebugLinkState::has_reset_word() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugLinkState::set_has_reset_word() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugLinkState::clear_has_reset_word() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugLinkState::clear_reset_word() {
  reset_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_word();
}
inline const ::std::string& DebugLinkState::reset_word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_word)
  return reset_word_.GetNoArena();
}
inline void DebugLinkState::set_reset_word(const ::std::string& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_word(::std::string&& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
#endif
inline void DebugLinkState::set_reset_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
inline void DebugLinkState::set_reset_word(const char* value, size_t size) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
inline ::std::string* DebugLinkState::mutable_reset_word() {
  set_has_reset_word();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.reset_word)
  return reset_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_word() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.reset_word)
  if (!has_reset_word()) {
    return NULL;
  }
  clear_has_reset_word();
  return reset_word_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_word(::std::string* reset_word) {
  if (reset_word != NULL) {
    set_has_reset_word();
  } else {
    clear_has_reset_word();
  }
  reset_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_word);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.reset_word)
}

// optional bytes reset_entropy = 8;
inline bool DebugLinkState::has_reset_entropy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugLinkState::set_has_reset_entropy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DebugLinkState::clear_has_reset_entropy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DebugLinkState::clear_reset_entropy() {
  reset_entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_entropy();
}
inline const ::std::string& DebugLinkState::reset_entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  return reset_entropy_.GetNoArena();
}
inline void DebugLinkState::set_reset_entropy(const ::std::string& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_entropy(::std::string&& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
#endif
inline void DebugLinkState::set_reset_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
inline void DebugLinkState::set_reset_entropy(const void* value, size_t size) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
inline ::std::string* DebugLinkState::mutable_reset_entropy() {
  set_has_reset_entropy();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  return reset_entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_entropy() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  if (!has_reset_entropy()) {
    return NULL;
  }
  clear_has_reset_entropy();
  return reset_entropy_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_entropy(::std::string* reset_entropy) {
  if (reset_entropy != NULL) {
    set_has_reset_entropy();
  } else {
    clear_has_reset_entropy();
  }
  reset_entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_entropy);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}

// optional string recovery_fake_word = 9;
inline bool DebugLinkState::has_recovery_fake_word() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DebugLinkState::set_has_recovery_fake_word() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DebugLinkState::clear_has_recovery_fake_word() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DebugLinkState::clear_recovery_fake_word() {
  recovery_fake_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recovery_fake_word();
}
inline const ::std::string& DebugLinkState::recovery_fake_word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.GetNoArena();
}
inline void DebugLinkState::set_recovery_fake_word(const ::std::string& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_recovery_fake_word(::std::string&& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
#endif
inline void DebugLinkState::set_recovery_fake_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
inline void DebugLinkState::set_recovery_fake_word(const char* value, size_t size) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
inline ::std::string* DebugLinkState::mutable_recovery_fake_word() {
  set_has_recovery_fake_word();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_recovery_fake_word() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  if (!has_recovery_fake_word()) {
    return NULL;
  }
  clear_has_recovery_fake_word();
  return recovery_fake_word_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_recovery_fake_word(::std::string* recovery_fake_word) {
  if (recovery_fake_word != NULL) {
    set_has_recovery_fake_word();
  } else {
    clear_has_recovery_fake_word();
  }
  recovery_fake_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recovery_fake_word);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}

// optional uint32 recovery_word_pos = 10;
inline bool DebugLinkState::has_recovery_word_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DebugLinkState::set_has_recovery_word_pos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DebugLinkState::clear_has_recovery_word_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DebugLinkState::clear_recovery_word_pos() {
  recovery_word_pos_ = 0u;
  clear_has_recovery_word_pos();
}
inline ::google::protobuf::uint32 DebugLinkState::recovery_word_pos() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.recovery_word_pos)
  return recovery_word_pos_;
}
inline void DebugLinkState::set_recovery_word_pos(::google::protobuf::uint32 value) {
  set_has_recovery_word_pos();
  recovery_word_pos_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.recovery_word_pos)
}

// optional uint32 reset_word_pos = 11;
inline bool DebugLinkState::has_reset_word_pos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DebugLinkState::set_has_reset_word_pos() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DebugLinkState::clear_has_reset_word_pos() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DebugLinkState::clear_reset_word_pos() {
  reset_word_pos_ = 0u;
  clear_has_reset_word_pos();
}
inline ::google::protobuf::uint32 DebugLinkState::reset_word_pos() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_word_pos)
  return reset_word_pos_;
}
inline void DebugLinkState::set_reset_word_pos(::google::protobuf::uint32 value) {
  set_has_reset_word_pos();
  reset_word_pos_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_word_pos)
}

// -------------------------------------------------------------------

// DebugLinkStop

// -------------------------------------------------------------------

// DebugLinkLog

// optional uint32 level = 1;
inline bool DebugLinkLog::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkLog::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkLog::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkLog::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 DebugLinkLog::level() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.level)
  return level_;
}
inline void DebugLinkLog::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.level)
}

// optional string bucket = 2;
inline bool DebugLinkLog::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkLog::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkLog::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkLog::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bucket();
}
inline const ::std::string& DebugLinkLog::bucket() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.bucket)
  return bucket_.GetNoArena();
}
inline void DebugLinkLog::set_bucket(const ::std::string& value) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
#if LANG_CXX11
inline void DebugLinkLog::set_bucket(::std::string&& value) {
  set_has_bucket();
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
#endif
inline void DebugLinkLog::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
inline void DebugLinkLog::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
inline ::std::string* DebugLinkLog::mutable_bucket() {
  set_has_bucket();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkLog.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_bucket() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkLog.bucket)
  if (!has_bucket()) {
    return NULL;
  }
  clear_has_bucket();
  return bucket_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    set_has_bucket();
  } else {
    clear_has_bucket();
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkLog.bucket)
}

// optional string text = 3;
inline bool DebugLinkLog::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkLog::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkLog::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkLog::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DebugLinkLog::text() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.text)
  return text_.GetNoArena();
}
inline void DebugLinkLog::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.text)
}
#if LANG_CXX11
inline void DebugLinkLog::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkLog.text)
}
#endif
inline void DebugLinkLog::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkLog.text)
}
inline void DebugLinkLog::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkLog.text)
}
inline ::std::string* DebugLinkLog::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkLog.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_text() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkLog.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkLog.text)
}

// -------------------------------------------------------------------

// DebugLinkMemoryRead

// optional uint32 address = 1;
inline bool DebugLinkMemoryRead::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryRead::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemoryRead::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemoryRead::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryRead.address)
  return address_;
}
inline void DebugLinkMemoryRead::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryRead.address)
}

// optional uint32 length = 2;
inline bool DebugLinkMemoryRead::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryRead::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkMemoryRead::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkMemoryRead::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::length() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryRead.length)
  return length_;
}
inline void DebugLinkMemoryRead::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryRead.length)
}

// -------------------------------------------------------------------

// DebugLinkMemory

// optional bytes memory = 1;
inline bool DebugLinkMemory::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemory::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemory::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemory::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
inline const ::std::string& DebugLinkMemory::memory() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemory.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemory::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
#if LANG_CXX11
inline void DebugLinkMemory::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
#endif
inline void DebugLinkMemory::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
inline void DebugLinkMemory::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
inline ::std::string* DebugLinkMemory::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkMemory.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemory::release_memory() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkMemory.memory)
  if (!has_memory()) {
    return NULL;
  }
  clear_has_memory();
  return memory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemory::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkMemory.memory)
}

// -------------------------------------------------------------------

// DebugLinkMemoryWrite

// optional uint32 address = 1;
inline bool DebugLinkMemoryWrite::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkMemoryWrite::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkMemoryWrite::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 DebugLinkMemoryWrite::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.address)
  return address_;
}
inline void DebugLinkMemoryWrite::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.address)
}

// optional bytes memory = 2;
inline bool DebugLinkMemoryWrite::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemoryWrite::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemoryWrite::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
inline const ::std::string& DebugLinkMemoryWrite::memory() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemoryWrite::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
#if LANG_CXX11
inline void DebugLinkMemoryWrite::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
#endif
inline void DebugLinkMemoryWrite::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
inline void DebugLinkMemoryWrite::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
inline ::std::string* DebugLinkMemoryWrite::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemoryWrite::release_memory() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  if (!has_memory()) {
    return NULL;
  }
  clear_has_memory();
  return memory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemoryWrite::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}

// optional bool flash = 3;
inline bool DebugLinkMemoryWrite::has_flash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_flash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkMemoryWrite::clear_has_flash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkMemoryWrite::clear_flash() {
  flash_ = false;
  clear_has_flash();
}
inline bool DebugLinkMemoryWrite::flash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.flash)
  return flash_;
}
inline void DebugLinkMemoryWrite::set_flash(bool value) {
  set_has_flash();
  flash_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.flash)
}

// -------------------------------------------------------------------

// DebugLinkFlashErase

// optional uint32 sector = 1;
inline bool DebugLinkFlashErase::has_sector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkFlashErase::set_has_sector() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkFlashErase::clear_has_sector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkFlashErase::clear_sector() {
  sector_ = 0u;
  clear_has_sector();
}
inline ::google::protobuf::uint32 DebugLinkFlashErase::sector() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkFlashErase.sector)
  return sector_;
}
inline void DebugLinkFlashErase::set_sector(::google::protobuf::uint32 value) {
  set_has_sector();
  sector_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkFlashErase.sector)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace debug
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2ddebug_2eproto
