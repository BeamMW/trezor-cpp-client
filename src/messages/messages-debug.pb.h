// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-debug.proto

#ifndef PROTOBUF_INCLUDED_messages_2ddebug_2eproto
#define PROTOBUF_INCLUDED_messages_2ddebug_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2ddebug_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2ddebug_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2ddebug_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace debug {
class DebugLinkDecision;
class DebugLinkDecisionDefaultTypeInternal;
extern DebugLinkDecisionDefaultTypeInternal _DebugLinkDecision_default_instance_;
class DebugLinkFlashErase;
class DebugLinkFlashEraseDefaultTypeInternal;
extern DebugLinkFlashEraseDefaultTypeInternal _DebugLinkFlashErase_default_instance_;
class DebugLinkGetState;
class DebugLinkGetStateDefaultTypeInternal;
extern DebugLinkGetStateDefaultTypeInternal _DebugLinkGetState_default_instance_;
class DebugLinkLayout;
class DebugLinkLayoutDefaultTypeInternal;
extern DebugLinkLayoutDefaultTypeInternal _DebugLinkLayout_default_instance_;
class DebugLinkLog;
class DebugLinkLogDefaultTypeInternal;
extern DebugLinkLogDefaultTypeInternal _DebugLinkLog_default_instance_;
class DebugLinkMemory;
class DebugLinkMemoryDefaultTypeInternal;
extern DebugLinkMemoryDefaultTypeInternal _DebugLinkMemory_default_instance_;
class DebugLinkMemoryRead;
class DebugLinkMemoryReadDefaultTypeInternal;
extern DebugLinkMemoryReadDefaultTypeInternal _DebugLinkMemoryRead_default_instance_;
class DebugLinkMemoryWrite;
class DebugLinkMemoryWriteDefaultTypeInternal;
extern DebugLinkMemoryWriteDefaultTypeInternal _DebugLinkMemoryWrite_default_instance_;
class DebugLinkState;
class DebugLinkStateDefaultTypeInternal;
extern DebugLinkStateDefaultTypeInternal _DebugLinkState_default_instance_;
class DebugLinkStop;
class DebugLinkStopDefaultTypeInternal;
extern DebugLinkStopDefaultTypeInternal _DebugLinkStop_default_instance_;
}  // namespace debug
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::debug::DebugLinkDecision* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkDecision>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkFlashErase* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkFlashErase>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkGetState* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkGetState>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkLayout* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkLayout>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkLog* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkLog>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemory* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemory>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemoryRead* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemoryRead>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkMemoryWrite* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkMemoryWrite>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkState* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkState>(Arena*);
template<> ::hw::trezor::messages::debug::DebugLinkStop* Arena::CreateMaybeMessage<::hw::trezor::messages::debug::DebugLinkStop>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace debug {

enum DebugLinkDecision_DebugSwipeDirection {
  DebugLinkDecision_DebugSwipeDirection_UP = 0,
  DebugLinkDecision_DebugSwipeDirection_DOWN = 1,
  DebugLinkDecision_DebugSwipeDirection_LEFT = 2,
  DebugLinkDecision_DebugSwipeDirection_RIGHT = 3
};
bool DebugLinkDecision_DebugSwipeDirection_IsValid(int value);
const DebugLinkDecision_DebugSwipeDirection DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_MIN = DebugLinkDecision_DebugSwipeDirection_UP;
const DebugLinkDecision_DebugSwipeDirection DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_MAX = DebugLinkDecision_DebugSwipeDirection_RIGHT;
const int DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_ARRAYSIZE = DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* DebugLinkDecision_DebugSwipeDirection_descriptor();
inline const ::std::string& DebugLinkDecision_DebugSwipeDirection_Name(DebugLinkDecision_DebugSwipeDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    DebugLinkDecision_DebugSwipeDirection_descriptor(), value);
}
inline bool DebugLinkDecision_DebugSwipeDirection_Parse(
    const ::std::string& name, DebugLinkDecision_DebugSwipeDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DebugLinkDecision_DebugSwipeDirection>(
    DebugLinkDecision_DebugSwipeDirection_descriptor(), name, value);
}
// ===================================================================

class DebugLinkDecision final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkDecision) */ {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();

  DebugLinkDecision(const DebugLinkDecision& from);

  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkDecision(DebugLinkDecision&& from) noexcept
    : DebugLinkDecision() {
    *this = ::std::move(from);
  }

  inline DebugLinkDecision& operator=(DebugLinkDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkDecision* internal_default_instance() {
    return reinterpret_cast<const DebugLinkDecision*>(
               &_DebugLinkDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DebugLinkDecision* other);
  friend void swap(DebugLinkDecision& a, DebugLinkDecision& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkDecision* New() const final {
    return CreateMaybeMessage<DebugLinkDecision>(nullptr);
  }

  DebugLinkDecision* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkDecision>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkDecision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugLinkDecision_DebugSwipeDirection DebugSwipeDirection;
  static const DebugSwipeDirection UP =
    DebugLinkDecision_DebugSwipeDirection_UP;
  static const DebugSwipeDirection DOWN =
    DebugLinkDecision_DebugSwipeDirection_DOWN;
  static const DebugSwipeDirection LEFT =
    DebugLinkDecision_DebugSwipeDirection_LEFT;
  static const DebugSwipeDirection RIGHT =
    DebugLinkDecision_DebugSwipeDirection_RIGHT;
  static inline bool DebugSwipeDirection_IsValid(int value) {
    return DebugLinkDecision_DebugSwipeDirection_IsValid(value);
  }
  static const DebugSwipeDirection DebugSwipeDirection_MIN =
    DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_MIN;
  static const DebugSwipeDirection DebugSwipeDirection_MAX =
    DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_MAX;
  static const int DebugSwipeDirection_ARRAYSIZE =
    DebugLinkDecision_DebugSwipeDirection_DebugSwipeDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DebugSwipeDirection_descriptor() {
    return DebugLinkDecision_DebugSwipeDirection_descriptor();
  }
  static inline const ::std::string& DebugSwipeDirection_Name(DebugSwipeDirection value) {
    return DebugLinkDecision_DebugSwipeDirection_Name(value);
  }
  static inline bool DebugSwipeDirection_Parse(const ::std::string& name,
      DebugSwipeDirection* value) {
    return DebugLinkDecision_DebugSwipeDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string input = 3;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  #if LANG_CXX11
  void set_input(::std::string&& value);
  #endif
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // optional .hw.trezor.messages.debug.DebugLinkDecision.DebugSwipeDirection swipe = 2;
  bool has_swipe() const;
  void clear_swipe();
  static const int kSwipeFieldNumber = 2;
  ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection swipe() const;
  void set_swipe(::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection value);

  // optional bool yes_no = 1;
  bool has_yes_no() const;
  void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  bool yes_no() const;
  void set_yes_no(bool value);

  // optional bool wait = 6;
  bool has_wait() const;
  void clear_wait();
  static const int kWaitFieldNumber = 6;
  bool wait() const;
  void set_wait(bool value);

  // optional uint32 x = 4;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 4;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 5;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 5;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkDecision)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  int swipe_;
  bool yes_no_;
  bool wait_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkLayout final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkLayout) */ {
 public:
  DebugLinkLayout();
  virtual ~DebugLinkLayout();

  DebugLinkLayout(const DebugLinkLayout& from);

  inline DebugLinkLayout& operator=(const DebugLinkLayout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkLayout(DebugLinkLayout&& from) noexcept
    : DebugLinkLayout() {
    *this = ::std::move(from);
  }

  inline DebugLinkLayout& operator=(DebugLinkLayout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkLayout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkLayout* internal_default_instance() {
    return reinterpret_cast<const DebugLinkLayout*>(
               &_DebugLinkLayout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DebugLinkLayout* other);
  friend void swap(DebugLinkLayout& a, DebugLinkLayout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkLayout* New() const final {
    return CreateMaybeMessage<DebugLinkLayout>(nullptr);
  }

  DebugLinkLayout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkLayout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkLayout& from);
  void MergeFrom(const DebugLinkLayout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkLayout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string lines = 1;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 1;
  const ::std::string& lines(int index) const;
  ::std::string* mutable_lines(int index);
  void set_lines(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lines(int index, ::std::string&& value);
  #endif
  void set_lines(int index, const char* value);
  void set_lines(int index, const char* value, size_t size);
  ::std::string* add_lines();
  void add_lines(const ::std::string& value);
  #if LANG_CXX11
  void add_lines(::std::string&& value);
  #endif
  void add_lines(const char* value);
  void add_lines(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& lines() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_lines();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkLayout)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> lines_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkGetState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkGetState) */ {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();

  DebugLinkGetState(const DebugLinkGetState& from);

  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkGetState(DebugLinkGetState&& from) noexcept
    : DebugLinkGetState() {
    *this = ::std::move(from);
  }

  inline DebugLinkGetState& operator=(DebugLinkGetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkGetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkGetState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkGetState*>(
               &_DebugLinkGetState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DebugLinkGetState* other);
  friend void swap(DebugLinkGetState& a, DebugLinkGetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkGetState* New() const final {
    return CreateMaybeMessage<DebugLinkGetState>(nullptr);
  }

  DebugLinkGetState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkGetState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkGetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool wait_word_list = 1;
  bool has_wait_word_list() const;
  void clear_wait_word_list();
  static const int kWaitWordListFieldNumber = 1;
  bool wait_word_list() const;
  void set_wait_word_list(bool value);

  // optional bool wait_word_pos = 2;
  bool has_wait_word_pos() const;
  void clear_wait_word_pos();
  static const int kWaitWordPosFieldNumber = 2;
  bool wait_word_pos() const;
  void set_wait_word_pos(bool value);

  // optional bool wait_layout = 3;
  bool has_wait_layout() const;
  void clear_wait_layout();
  static const int kWaitLayoutFieldNumber = 3;
  bool wait_layout() const;
  void set_wait_layout(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkGetState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool wait_word_list_;
  bool wait_word_pos_;
  bool wait_layout_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkState) */ {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();

  DebugLinkState(const DebugLinkState& from);

  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkState(DebugLinkState&& from) noexcept
    : DebugLinkState() {
    *this = ::std::move(from);
  }

  inline DebugLinkState& operator=(DebugLinkState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkState*>(
               &_DebugLinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DebugLinkState* other);
  friend void swap(DebugLinkState& a, DebugLinkState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkState* New() const final {
    return CreateMaybeMessage<DebugLinkState>(nullptr);
  }

  DebugLinkState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string layout_lines = 13;
  int layout_lines_size() const;
  void clear_layout_lines();
  static const int kLayoutLinesFieldNumber = 13;
  const ::std::string& layout_lines(int index) const;
  ::std::string* mutable_layout_lines(int index);
  void set_layout_lines(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_layout_lines(int index, ::std::string&& value);
  #endif
  void set_layout_lines(int index, const char* value);
  void set_layout_lines(int index, const char* value, size_t size);
  ::std::string* add_layout_lines();
  void add_layout_lines(const ::std::string& value);
  #if LANG_CXX11
  void add_layout_lines(::std::string&& value);
  #endif
  void add_layout_lines(const char* value);
  void add_layout_lines(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& layout_lines() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_layout_lines();

  // optional bytes layout = 1;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 1;
  const ::std::string& layout() const;
  void set_layout(const ::std::string& value);
  #if LANG_CXX11
  void set_layout(::std::string&& value);
  #endif
  void set_layout(const char* value);
  void set_layout(const void* value, size_t size);
  ::std::string* mutable_layout();
  ::std::string* release_layout();
  void set_allocated_layout(::std::string* layout);

  // optional string pin = 2;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // optional string matrix = 3;
  bool has_matrix() const;
  void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  const ::std::string& matrix() const;
  void set_matrix(const ::std::string& value);
  #if LANG_CXX11
  void set_matrix(::std::string&& value);
  #endif
  void set_matrix(const char* value);
  void set_matrix(const char* value, size_t size);
  ::std::string* mutable_matrix();
  ::std::string* release_matrix();
  void set_allocated_matrix(::std::string* matrix);

  // optional bytes mnemonic_secret = 4;
  bool has_mnemonic_secret() const;
  void clear_mnemonic_secret();
  static const int kMnemonicSecretFieldNumber = 4;
  const ::std::string& mnemonic_secret() const;
  void set_mnemonic_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_mnemonic_secret(::std::string&& value);
  #endif
  void set_mnemonic_secret(const char* value);
  void set_mnemonic_secret(const void* value, size_t size);
  ::std::string* mutable_mnemonic_secret();
  ::std::string* release_mnemonic_secret();
  void set_allocated_mnemonic_secret(::std::string* mnemonic_secret);

  // optional string reset_word = 7;
  bool has_reset_word() const;
  void clear_reset_word();
  static const int kResetWordFieldNumber = 7;
  const ::std::string& reset_word() const;
  void set_reset_word(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_word(::std::string&& value);
  #endif
  void set_reset_word(const char* value);
  void set_reset_word(const char* value, size_t size);
  ::std::string* mutable_reset_word();
  ::std::string* release_reset_word();
  void set_allocated_reset_word(::std::string* reset_word);

  // optional bytes reset_entropy = 8;
  bool has_reset_entropy() const;
  void clear_reset_entropy();
  static const int kResetEntropyFieldNumber = 8;
  const ::std::string& reset_entropy() const;
  void set_reset_entropy(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_entropy(::std::string&& value);
  #endif
  void set_reset_entropy(const char* value);
  void set_reset_entropy(const void* value, size_t size);
  ::std::string* mutable_reset_entropy();
  ::std::string* release_reset_entropy();
  void set_allocated_reset_entropy(::std::string* reset_entropy);

  // optional string recovery_fake_word = 9;
  bool has_recovery_fake_word() const;
  void clear_recovery_fake_word();
  static const int kRecoveryFakeWordFieldNumber = 9;
  const ::std::string& recovery_fake_word() const;
  void set_recovery_fake_word(const ::std::string& value);
  #if LANG_CXX11
  void set_recovery_fake_word(::std::string&& value);
  #endif
  void set_recovery_fake_word(const char* value);
  void set_recovery_fake_word(const char* value, size_t size);
  ::std::string* mutable_recovery_fake_word();
  ::std::string* release_recovery_fake_word();
  void set_allocated_recovery_fake_word(::std::string* recovery_fake_word);

  // optional .hw.trezor.messages.common.HDNodeType node = 5;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 5;
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // optional bool passphrase_protection = 6;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 6;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional uint32 recovery_word_pos = 10;
  bool has_recovery_word_pos() const;
  void clear_recovery_word_pos();
  static const int kRecoveryWordPosFieldNumber = 10;
  ::google::protobuf::uint32 recovery_word_pos() const;
  void set_recovery_word_pos(::google::protobuf::uint32 value);

  // optional uint32 reset_word_pos = 11;
  bool has_reset_word_pos() const;
  void clear_reset_word_pos();
  static const int kResetWordPosFieldNumber = 11;
  ::google::protobuf::uint32 reset_word_pos() const;
  void set_reset_word_pos(::google::protobuf::uint32 value);

  // optional uint32 mnemonic_type = 12;
  bool has_mnemonic_type() const;
  void clear_mnemonic_type();
  static const int kMnemonicTypeFieldNumber = 12;
  ::google::protobuf::uint32 mnemonic_type() const;
  void set_mnemonic_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> layout_lines_;
  ::google::protobuf::internal::ArenaStringPtr layout_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  ::google::protobuf::internal::ArenaStringPtr matrix_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_secret_;
  ::google::protobuf::internal::ArenaStringPtr reset_word_;
  ::google::protobuf::internal::ArenaStringPtr reset_entropy_;
  ::google::protobuf::internal::ArenaStringPtr recovery_fake_word_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  bool passphrase_protection_;
  ::google::protobuf::uint32 recovery_word_pos_;
  ::google::protobuf::uint32 reset_word_pos_;
  ::google::protobuf::uint32 mnemonic_type_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkStop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkStop) */ {
 public:
  DebugLinkStop();
  virtual ~DebugLinkStop();

  DebugLinkStop(const DebugLinkStop& from);

  inline DebugLinkStop& operator=(const DebugLinkStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkStop(DebugLinkStop&& from) noexcept
    : DebugLinkStop() {
    *this = ::std::move(from);
  }

  inline DebugLinkStop& operator=(DebugLinkStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkStop* internal_default_instance() {
    return reinterpret_cast<const DebugLinkStop*>(
               &_DebugLinkStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DebugLinkStop* other);
  friend void swap(DebugLinkStop& a, DebugLinkStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkStop* New() const final {
    return CreateMaybeMessage<DebugLinkStop>(nullptr);
  }

  DebugLinkStop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkStop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkStop& from);
  void MergeFrom(const DebugLinkStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkStop)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkLog final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkLog) */ {
 public:
  DebugLinkLog();
  virtual ~DebugLinkLog();

  DebugLinkLog(const DebugLinkLog& from);

  inline DebugLinkLog& operator=(const DebugLinkLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkLog(DebugLinkLog&& from) noexcept
    : DebugLinkLog() {
    *this = ::std::move(from);
  }

  inline DebugLinkLog& operator=(DebugLinkLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkLog* internal_default_instance() {
    return reinterpret_cast<const DebugLinkLog*>(
               &_DebugLinkLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DebugLinkLog* other);
  friend void swap(DebugLinkLog& a, DebugLinkLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkLog* New() const final {
    return CreateMaybeMessage<DebugLinkLog>(nullptr);
  }

  DebugLinkLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkLog& from);
  void MergeFrom(const DebugLinkLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 2;
  bool has_bucket() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 2;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkLog)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 level_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkMemoryRead final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemoryRead) */ {
 public:
  DebugLinkMemoryRead();
  virtual ~DebugLinkMemoryRead();

  DebugLinkMemoryRead(const DebugLinkMemoryRead& from);

  inline DebugLinkMemoryRead& operator=(const DebugLinkMemoryRead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemoryRead(DebugLinkMemoryRead&& from) noexcept
    : DebugLinkMemoryRead() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemoryRead& operator=(DebugLinkMemoryRead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkMemoryRead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemoryRead* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryRead*>(
               &_DebugLinkMemoryRead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DebugLinkMemoryRead* other);
  friend void swap(DebugLinkMemoryRead& a, DebugLinkMemoryRead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryRead* New() const final {
    return CreateMaybeMessage<DebugLinkMemoryRead>(nullptr);
  }

  DebugLinkMemoryRead* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemoryRead>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemoryRead& from);
  void MergeFrom(const DebugLinkMemoryRead& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemoryRead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional uint32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemoryRead)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 length_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkMemory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemory) */ {
 public:
  DebugLinkMemory();
  virtual ~DebugLinkMemory();

  DebugLinkMemory(const DebugLinkMemory& from);

  inline DebugLinkMemory& operator=(const DebugLinkMemory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemory(DebugLinkMemory&& from) noexcept
    : DebugLinkMemory() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemory& operator=(DebugLinkMemory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkMemory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemory* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemory*>(
               &_DebugLinkMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DebugLinkMemory* other);
  friend void swap(DebugLinkMemory& a, DebugLinkMemory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemory* New() const final {
    return CreateMaybeMessage<DebugLinkMemory>(nullptr);
  }

  DebugLinkMemory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemory& from);
  void MergeFrom(const DebugLinkMemory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 1;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 1;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemory)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkMemoryWrite final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkMemoryWrite) */ {
 public:
  DebugLinkMemoryWrite();
  virtual ~DebugLinkMemoryWrite();

  DebugLinkMemoryWrite(const DebugLinkMemoryWrite& from);

  inline DebugLinkMemoryWrite& operator=(const DebugLinkMemoryWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkMemoryWrite(DebugLinkMemoryWrite&& from) noexcept
    : DebugLinkMemoryWrite() {
    *this = ::std::move(from);
  }

  inline DebugLinkMemoryWrite& operator=(DebugLinkMemoryWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkMemoryWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkMemoryWrite* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryWrite*>(
               &_DebugLinkMemoryWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DebugLinkMemoryWrite* other);
  friend void swap(DebugLinkMemoryWrite& a, DebugLinkMemoryWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryWrite* New() const final {
    return CreateMaybeMessage<DebugLinkMemoryWrite>(nullptr);
  }

  DebugLinkMemoryWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkMemoryWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkMemoryWrite& from);
  void MergeFrom(const DebugLinkMemoryWrite& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkMemoryWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 2;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional bool flash = 3;
  bool has_flash() const;
  void clear_flash();
  static const int kFlashFieldNumber = 3;
  bool flash() const;
  void set_flash(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkMemoryWrite)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  ::google::protobuf::uint32 address_;
  bool flash_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLinkFlashErase final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.debug.DebugLinkFlashErase) */ {
 public:
  DebugLinkFlashErase();
  virtual ~DebugLinkFlashErase();

  DebugLinkFlashErase(const DebugLinkFlashErase& from);

  inline DebugLinkFlashErase& operator=(const DebugLinkFlashErase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugLinkFlashErase(DebugLinkFlashErase&& from) noexcept
    : DebugLinkFlashErase() {
    *this = ::std::move(from);
  }

  inline DebugLinkFlashErase& operator=(DebugLinkFlashErase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugLinkFlashErase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLinkFlashErase* internal_default_instance() {
    return reinterpret_cast<const DebugLinkFlashErase*>(
               &_DebugLinkFlashErase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DebugLinkFlashErase* other);
  friend void swap(DebugLinkFlashErase& a, DebugLinkFlashErase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugLinkFlashErase* New() const final {
    return CreateMaybeMessage<DebugLinkFlashErase>(nullptr);
  }

  DebugLinkFlashErase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugLinkFlashErase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugLinkFlashErase& from);
  void MergeFrom(const DebugLinkFlashErase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLinkFlashErase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sector = 1;
  bool has_sector() const;
  void clear_sector();
  static const int kSectorFieldNumber = 1;
  ::google::protobuf::uint32 sector() const;
  void set_sector(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.debug.DebugLinkFlashErase)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sector_;
  friend struct ::TableStruct_messages_2ddebug_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugLinkDecision

// optional bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DebugLinkDecision::yes_no() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.yes_no)
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  _has_bits_[0] |= 0x00000004u;
  yes_no_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.yes_no)
}

// optional .hw.trezor.messages.debug.DebugLinkDecision.DebugSwipeDirection swipe = 2;
inline bool DebugLinkDecision::has_swipe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkDecision::clear_swipe() {
  swipe_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection DebugLinkDecision::swipe() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.swipe)
  return static_cast< ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection >(swipe_);
}
inline void DebugLinkDecision::set_swipe(::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection value) {
  assert(::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  swipe_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.swipe)
}

// optional string input = 3;
inline bool DebugLinkDecision::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugLinkDecision::input() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.input)
  return input_.GetNoArena();
}
inline void DebugLinkDecision::set_input(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.input)
}
#if LANG_CXX11
inline void DebugLinkDecision::set_input(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkDecision.input)
}
#endif
inline void DebugLinkDecision::set_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkDecision.input)
}
inline void DebugLinkDecision::set_input(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkDecision.input)
}
inline ::std::string* DebugLinkDecision::mutable_input() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkDecision.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkDecision::release_input() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkDecision.input)
  if (!has_input()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return input_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkDecision::set_allocated_input(::std::string* input) {
  if (input != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkDecision.input)
}

// optional uint32 x = 4;
inline bool DebugLinkDecision::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugLinkDecision::clear_x() {
  x_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 DebugLinkDecision::x() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.x)
  return x_;
}
inline void DebugLinkDecision::set_x(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  x_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.x)
}

// optional uint32 y = 5;
inline bool DebugLinkDecision::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugLinkDecision::clear_y() {
  y_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 DebugLinkDecision::y() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.y)
  return y_;
}
inline void DebugLinkDecision::set_y(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  y_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.y)
}

// optional bool wait = 6;
inline bool DebugLinkDecision::has_wait() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkDecision::clear_wait() {
  wait_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DebugLinkDecision::wait() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkDecision.wait)
  return wait_;
}
inline void DebugLinkDecision::set_wait(bool value) {
  _has_bits_[0] |= 0x00000008u;
  wait_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkDecision.wait)
}

// -------------------------------------------------------------------

// DebugLinkLayout

// repeated string lines = 1;
inline int DebugLinkLayout::lines_size() const {
  return lines_.size();
}
inline void DebugLinkLayout::clear_lines() {
  lines_.Clear();
}
inline const ::std::string& DebugLinkLayout::lines(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLayout.lines)
  return lines_.Get(index);
}
inline ::std::string* DebugLinkLayout::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkLayout.lines)
  return lines_.Mutable(index);
}
inline void DebugLinkLayout::set_lines(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLayout.lines)
  lines_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DebugLinkLayout::set_lines(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLayout.lines)
  lines_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DebugLinkLayout::set_lines(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lines_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
inline void DebugLinkLayout::set_lines(int index, const char* value, size_t size) {
  lines_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
inline ::std::string* DebugLinkLayout::add_lines() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.debug.DebugLinkLayout.lines)
  return lines_.Add();
}
inline void DebugLinkLayout::add_lines(const ::std::string& value) {
  lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
#if LANG_CXX11
inline void DebugLinkLayout::add_lines(::std::string&& value) {
  lines_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
#endif
inline void DebugLinkLayout::add_lines(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
inline void DebugLinkLayout::add_lines(const char* value, size_t size) {
  lines_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.debug.DebugLinkLayout.lines)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DebugLinkLayout::lines() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.debug.DebugLinkLayout.lines)
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DebugLinkLayout::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.debug.DebugLinkLayout.lines)
  return &lines_;
}

// -------------------------------------------------------------------

// DebugLinkGetState

// optional bool wait_word_list = 1;
inline bool DebugLinkGetState::has_wait_word_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkGetState::clear_wait_word_list() {
  wait_word_list_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DebugLinkGetState::wait_word_list() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkGetState.wait_word_list)
  return wait_word_list_;
}
inline void DebugLinkGetState::set_wait_word_list(bool value) {
  _has_bits_[0] |= 0x00000001u;
  wait_word_list_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkGetState.wait_word_list)
}

// optional bool wait_word_pos = 2;
inline bool DebugLinkGetState::has_wait_word_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkGetState::clear_wait_word_pos() {
  wait_word_pos_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DebugLinkGetState::wait_word_pos() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkGetState.wait_word_pos)
  return wait_word_pos_;
}
inline void DebugLinkGetState::set_wait_word_pos(bool value) {
  _has_bits_[0] |= 0x00000002u;
  wait_word_pos_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkGetState.wait_word_pos)
}

// optional bool wait_layout = 3;
inline bool DebugLinkGetState::has_wait_layout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkGetState::clear_wait_layout() {
  wait_layout_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DebugLinkGetState::wait_layout() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkGetState.wait_layout)
  return wait_layout_;
}
inline void DebugLinkGetState::set_wait_layout(bool value) {
  _has_bits_[0] |= 0x00000004u;
  wait_layout_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkGetState.wait_layout)
}

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugLinkState::layout() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.layout)
  return layout_.GetNoArena();
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.layout)
}
#if LANG_CXX11
inline void DebugLinkState::set_layout(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.layout)
}
#endif
inline void DebugLinkState::set_layout(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.layout)
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.layout)
}
inline ::std::string* DebugLinkState::mutable_layout() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_layout() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.layout)
  if (!has_layout()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return layout_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.layout)
}

// optional string pin = 2;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DebugLinkState::pin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.pin)
  return pin_.GetNoArena();
}
inline void DebugLinkState::set_pin(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.pin)
}
#if LANG_CXX11
inline void DebugLinkState::set_pin(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.pin)
}
#endif
inline void DebugLinkState::set_pin(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.pin)
}
inline void DebugLinkState::set_pin(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.pin)
}
inline ::std::string* DebugLinkState::mutable_pin() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_pin() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.pin)
  if (!has_pin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.pin)
}

// optional string matrix = 3;
inline bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::clear_matrix() {
  matrix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& DebugLinkState::matrix() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.matrix)
  return matrix_.GetNoArena();
}
inline void DebugLinkState::set_matrix(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.matrix)
}
#if LANG_CXX11
inline void DebugLinkState::set_matrix(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  matrix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.matrix)
}
#endif
inline void DebugLinkState::set_matrix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.matrix)
}
inline void DebugLinkState::set_matrix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.matrix)
}
inline ::std::string* DebugLinkState::mutable_matrix() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.matrix)
  return matrix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_matrix() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.matrix)
  if (!has_matrix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return matrix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  matrix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matrix);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.matrix)
}

// optional bytes mnemonic_secret = 4;
inline bool DebugLinkState::has_mnemonic_secret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::clear_mnemonic_secret() {
  mnemonic_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& DebugLinkState::mnemonic_secret() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
  return mnemonic_secret_.GetNoArena();
}
inline void DebugLinkState::set_mnemonic_secret(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  mnemonic_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
}
#if LANG_CXX11
inline void DebugLinkState::set_mnemonic_secret(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  mnemonic_secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
}
#endif
inline void DebugLinkState::set_mnemonic_secret(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  mnemonic_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
}
inline void DebugLinkState::set_mnemonic_secret(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  mnemonic_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
}
inline ::std::string* DebugLinkState::mutable_mnemonic_secret() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
  return mnemonic_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_mnemonic_secret() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
  if (!has_mnemonic_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return mnemonic_secret_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_mnemonic_secret(::std::string* mnemonic_secret) {
  if (mnemonic_secret != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mnemonic_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic_secret);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.mnemonic_secret)
}

// optional .hw.trezor.messages.common.HDNodeType node = 5;
inline bool DebugLinkState::has_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline const ::hw::trezor::messages::common::HDNodeType& DebugLinkState::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* DebugLinkState::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.node)
  _has_bits_[0] &= ~0x00000080u;
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* DebugLinkState::mutable_node() {
  _has_bits_[0] |= 0x00000080u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.node)
  return node_;
}
inline void DebugLinkState::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.node)
}

// optional bool passphrase_protection = 6;
inline bool DebugLinkState::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DebugLinkState::clear_passphrase_protection() {
  passphrase_protection_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool DebugLinkState::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.passphrase_protection)
  return passphrase_protection_;
}
inline void DebugLinkState::set_passphrase_protection(bool value) {
  _has_bits_[0] |= 0x00000100u;
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.passphrase_protection)
}

// optional string reset_word = 7;
inline bool DebugLinkState::has_reset_word() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugLinkState::clear_reset_word() {
  reset_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& DebugLinkState::reset_word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_word)
  return reset_word_.GetNoArena();
}
inline void DebugLinkState::set_reset_word(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_word(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  reset_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
#endif
inline void DebugLinkState::set_reset_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
inline void DebugLinkState::set_reset_word(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.reset_word)
}
inline ::std::string* DebugLinkState::mutable_reset_word() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.reset_word)
  return reset_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_word() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.reset_word)
  if (!has_reset_word()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return reset_word_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_word(::std::string* reset_word) {
  if (reset_word != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  reset_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_word);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.reset_word)
}

// optional bytes reset_entropy = 8;
inline bool DebugLinkState::has_reset_entropy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugLinkState::clear_reset_entropy() {
  reset_entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& DebugLinkState::reset_entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  return reset_entropy_.GetNoArena();
}
inline void DebugLinkState::set_reset_entropy(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_entropy(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  reset_entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
#endif
inline void DebugLinkState::set_reset_entropy(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
inline void DebugLinkState::set_reset_entropy(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}
inline ::std::string* DebugLinkState::mutable_reset_entropy() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  return reset_entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_entropy() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
  if (!has_reset_entropy()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return reset_entropy_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_entropy(::std::string* reset_entropy) {
  if (reset_entropy != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  reset_entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_entropy);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.reset_entropy)
}

// optional string recovery_fake_word = 9;
inline bool DebugLinkState::has_recovery_fake_word() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DebugLinkState::clear_recovery_fake_word() {
  recovery_fake_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& DebugLinkState::recovery_fake_word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.GetNoArena();
}
inline void DebugLinkState::set_recovery_fake_word(const ::std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_recovery_fake_word(::std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  recovery_fake_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
#endif
inline void DebugLinkState::set_recovery_fake_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
inline void DebugLinkState::set_recovery_fake_word(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}
inline ::std::string* DebugLinkState::mutable_recovery_fake_word() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_recovery_fake_word() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
  if (!has_recovery_fake_word()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return recovery_fake_word_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_recovery_fake_word(::std::string* recovery_fake_word) {
  if (recovery_fake_word != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  recovery_fake_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recovery_fake_word);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkState.recovery_fake_word)
}

// optional uint32 recovery_word_pos = 10;
inline bool DebugLinkState::has_recovery_word_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DebugLinkState::clear_recovery_word_pos() {
  recovery_word_pos_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 DebugLinkState::recovery_word_pos() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.recovery_word_pos)
  return recovery_word_pos_;
}
inline void DebugLinkState::set_recovery_word_pos(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  recovery_word_pos_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.recovery_word_pos)
}

// optional uint32 reset_word_pos = 11;
inline bool DebugLinkState::has_reset_word_pos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DebugLinkState::clear_reset_word_pos() {
  reset_word_pos_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 DebugLinkState::reset_word_pos() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.reset_word_pos)
  return reset_word_pos_;
}
inline void DebugLinkState::set_reset_word_pos(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  reset_word_pos_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.reset_word_pos)
}

// optional uint32 mnemonic_type = 12;
inline bool DebugLinkState::has_mnemonic_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DebugLinkState::clear_mnemonic_type() {
  mnemonic_type_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 DebugLinkState::mnemonic_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.mnemonic_type)
  return mnemonic_type_;
}
inline void DebugLinkState::set_mnemonic_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  mnemonic_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.mnemonic_type)
}

// repeated string layout_lines = 13;
inline int DebugLinkState::layout_lines_size() const {
  return layout_lines_.size();
}
inline void DebugLinkState::clear_layout_lines() {
  layout_lines_.Clear();
}
inline const ::std::string& DebugLinkState::layout_lines(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  return layout_lines_.Get(index);
}
inline ::std::string* DebugLinkState::mutable_layout_lines(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  return layout_lines_.Mutable(index);
}
inline void DebugLinkState::set_layout_lines(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  layout_lines_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DebugLinkState::set_layout_lines(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  layout_lines_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DebugLinkState::set_layout_lines(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  layout_lines_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
inline void DebugLinkState::set_layout_lines(int index, const char* value, size_t size) {
  layout_lines_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
inline ::std::string* DebugLinkState::add_layout_lines() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  return layout_lines_.Add();
}
inline void DebugLinkState::add_layout_lines(const ::std::string& value) {
  layout_lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
#if LANG_CXX11
inline void DebugLinkState::add_layout_lines(::std::string&& value) {
  layout_lines_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
#endif
inline void DebugLinkState::add_layout_lines(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  layout_lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
inline void DebugLinkState::add_layout_lines(const char* value, size_t size) {
  layout_lines_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.debug.DebugLinkState.layout_lines)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DebugLinkState::layout_lines() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  return layout_lines_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DebugLinkState::mutable_layout_lines() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.debug.DebugLinkState.layout_lines)
  return &layout_lines_;
}

// -------------------------------------------------------------------

// DebugLinkStop

// -------------------------------------------------------------------

// DebugLinkLog

// optional uint32 level = 1;
inline bool DebugLinkLog::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkLog::clear_level() {
  level_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 DebugLinkLog::level() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.level)
  return level_;
}
inline void DebugLinkLog::set_level(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  level_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.level)
}

// optional string bucket = 2;
inline bool DebugLinkLog::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkLog::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugLinkLog::bucket() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.bucket)
  return bucket_.GetNoArena();
}
inline void DebugLinkLog::set_bucket(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
#if LANG_CXX11
inline void DebugLinkLog::set_bucket(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
#endif
inline void DebugLinkLog::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
inline void DebugLinkLog::set_bucket(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkLog.bucket)
}
inline ::std::string* DebugLinkLog::mutable_bucket() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkLog.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_bucket() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkLog.bucket)
  if (!has_bucket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bucket_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_bucket(::std::string* bucket) {
  if (bucket != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkLog.bucket)
}

// optional string text = 3;
inline bool DebugLinkLog::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkLog::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DebugLinkLog::text() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkLog.text)
  return text_.GetNoArena();
}
inline void DebugLinkLog::set_text(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkLog.text)
}
#if LANG_CXX11
inline void DebugLinkLog::set_text(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkLog.text)
}
#endif
inline void DebugLinkLog::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkLog.text)
}
inline void DebugLinkLog::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkLog.text)
}
inline ::std::string* DebugLinkLog::mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkLog.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_text() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkLog.text)
  if (!has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_text(::std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkLog.text)
}

// -------------------------------------------------------------------

// DebugLinkMemoryRead

// optional uint32 address = 1;
inline bool DebugLinkMemoryRead::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryRead::clear_address() {
  address_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryRead.address)
  return address_;
}
inline void DebugLinkMemoryRead::set_address(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  address_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryRead.address)
}

// optional uint32 length = 2;
inline bool DebugLinkMemoryRead::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryRead::clear_length() {
  length_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::length() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryRead.length)
  return length_;
}
inline void DebugLinkMemoryRead::set_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  length_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryRead.length)
}

// -------------------------------------------------------------------

// DebugLinkMemory

// optional bytes memory = 1;
inline bool DebugLinkMemory::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemory::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugLinkMemory::memory() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemory.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemory::set_memory(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
#if LANG_CXX11
inline void DebugLinkMemory::set_memory(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
#endif
inline void DebugLinkMemory::set_memory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
inline void DebugLinkMemory::set_memory(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkMemory.memory)
}
inline ::std::string* DebugLinkMemory::mutable_memory() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkMemory.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemory::release_memory() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkMemory.memory)
  if (!has_memory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return memory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemory::set_allocated_memory(::std::string* memory) {
  if (memory != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkMemory.memory)
}

// -------------------------------------------------------------------

// DebugLinkMemoryWrite

// optional uint32 address = 1;
inline bool DebugLinkMemoryWrite::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryWrite::clear_address() {
  address_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 DebugLinkMemoryWrite::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.address)
  return address_;
}
inline void DebugLinkMemoryWrite::set_address(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  address_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.address)
}

// optional bytes memory = 2;
inline bool DebugLinkMemoryWrite::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryWrite::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugLinkMemoryWrite::memory() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemoryWrite::set_memory(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
#if LANG_CXX11
inline void DebugLinkMemoryWrite::set_memory(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
#endif
inline void DebugLinkMemoryWrite::set_memory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
inline void DebugLinkMemoryWrite::set_memory(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}
inline ::std::string* DebugLinkMemoryWrite::mutable_memory() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemoryWrite::release_memory() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
  if (!has_memory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return memory_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemoryWrite::set_allocated_memory(::std::string* memory) {
  if (memory != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.debug.DebugLinkMemoryWrite.memory)
}

// optional bool flash = 3;
inline bool DebugLinkMemoryWrite::has_flash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkMemoryWrite::clear_flash() {
  flash_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DebugLinkMemoryWrite::flash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkMemoryWrite.flash)
  return flash_;
}
inline void DebugLinkMemoryWrite::set_flash(bool value) {
  _has_bits_[0] |= 0x00000004u;
  flash_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkMemoryWrite.flash)
}

// -------------------------------------------------------------------

// DebugLinkFlashErase

// optional uint32 sector = 1;
inline bool DebugLinkFlashErase::has_sector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkFlashErase::clear_sector() {
  sector_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 DebugLinkFlashErase::sector() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.debug.DebugLinkFlashErase.sector)
  return sector_;
}
inline void DebugLinkFlashErase::set_sector(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sector_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.debug.DebugLinkFlashErase.sector)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace debug
}  // namespace messages
}  // namespace trezor
}  // namespace hw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection>() {
  return ::hw::trezor::messages::debug::DebugLinkDecision_DebugSwipeDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2ddebug_2eproto
