// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-binance.proto

#ifndef PROTOBUF_INCLUDED_messages_2dbinance_2eproto
#define PROTOBUF_INCLUDED_messages_2dbinance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dbinance_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dbinance_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dbinance_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace binance {
class BinanceAddress;
class BinanceAddressDefaultTypeInternal;
extern BinanceAddressDefaultTypeInternal _BinanceAddress_default_instance_;
class BinanceCancelMsg;
class BinanceCancelMsgDefaultTypeInternal;
extern BinanceCancelMsgDefaultTypeInternal _BinanceCancelMsg_default_instance_;
class BinanceGetAddress;
class BinanceGetAddressDefaultTypeInternal;
extern BinanceGetAddressDefaultTypeInternal _BinanceGetAddress_default_instance_;
class BinanceGetPublicKey;
class BinanceGetPublicKeyDefaultTypeInternal;
extern BinanceGetPublicKeyDefaultTypeInternal _BinanceGetPublicKey_default_instance_;
class BinanceOrderMsg;
class BinanceOrderMsgDefaultTypeInternal;
extern BinanceOrderMsgDefaultTypeInternal _BinanceOrderMsg_default_instance_;
class BinancePublicKey;
class BinancePublicKeyDefaultTypeInternal;
extern BinancePublicKeyDefaultTypeInternal _BinancePublicKey_default_instance_;
class BinanceSignTx;
class BinanceSignTxDefaultTypeInternal;
extern BinanceSignTxDefaultTypeInternal _BinanceSignTx_default_instance_;
class BinanceSignedTx;
class BinanceSignedTxDefaultTypeInternal;
extern BinanceSignedTxDefaultTypeInternal _BinanceSignedTx_default_instance_;
class BinanceTransferMsg;
class BinanceTransferMsgDefaultTypeInternal;
extern BinanceTransferMsgDefaultTypeInternal _BinanceTransferMsg_default_instance_;
class BinanceTransferMsg_BinanceCoin;
class BinanceTransferMsg_BinanceCoinDefaultTypeInternal;
extern BinanceTransferMsg_BinanceCoinDefaultTypeInternal _BinanceTransferMsg_BinanceCoin_default_instance_;
class BinanceTransferMsg_BinanceInputOutput;
class BinanceTransferMsg_BinanceInputOutputDefaultTypeInternal;
extern BinanceTransferMsg_BinanceInputOutputDefaultTypeInternal _BinanceTransferMsg_BinanceInputOutput_default_instance_;
class BinanceTxRequest;
class BinanceTxRequestDefaultTypeInternal;
extern BinanceTxRequestDefaultTypeInternal _BinanceTxRequest_default_instance_;
}  // namespace binance
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::binance::BinanceAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceAddress>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceCancelMsg* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceCancelMsg>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceGetAddress>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceOrderMsg* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceOrderMsg>(Arena*);
template<> ::hw::trezor::messages::binance::BinancePublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinancePublicKey>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceSignTx>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceSignedTx>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceTransferMsg* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceTransferMsg>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput>(Arena*);
template<> ::hw::trezor::messages::binance::BinanceTxRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::binance::BinanceTxRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace binance {

enum BinanceOrderMsg_BinanceOrderType {
  BinanceOrderMsg_BinanceOrderType_OT_UNKNOWN = 0,
  BinanceOrderMsg_BinanceOrderType_MARKET = 1,
  BinanceOrderMsg_BinanceOrderType_LIMIT = 2,
  BinanceOrderMsg_BinanceOrderType_OT_RESERVED = 3
};
bool BinanceOrderMsg_BinanceOrderType_IsValid(int value);
const BinanceOrderMsg_BinanceOrderType BinanceOrderMsg_BinanceOrderType_BinanceOrderType_MIN = BinanceOrderMsg_BinanceOrderType_OT_UNKNOWN;
const BinanceOrderMsg_BinanceOrderType BinanceOrderMsg_BinanceOrderType_BinanceOrderType_MAX = BinanceOrderMsg_BinanceOrderType_OT_RESERVED;
const int BinanceOrderMsg_BinanceOrderType_BinanceOrderType_ARRAYSIZE = BinanceOrderMsg_BinanceOrderType_BinanceOrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinanceOrderMsg_BinanceOrderType_descriptor();
inline const ::std::string& BinanceOrderMsg_BinanceOrderType_Name(BinanceOrderMsg_BinanceOrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinanceOrderMsg_BinanceOrderType_descriptor(), value);
}
inline bool BinanceOrderMsg_BinanceOrderType_Parse(
    const ::std::string& name, BinanceOrderMsg_BinanceOrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinanceOrderMsg_BinanceOrderType>(
    BinanceOrderMsg_BinanceOrderType_descriptor(), name, value);
}
enum BinanceOrderMsg_BinanceOrderSide {
  BinanceOrderMsg_BinanceOrderSide_SIDE_UNKNOWN = 0,
  BinanceOrderMsg_BinanceOrderSide_BUY = 1,
  BinanceOrderMsg_BinanceOrderSide_SELL = 2
};
bool BinanceOrderMsg_BinanceOrderSide_IsValid(int value);
const BinanceOrderMsg_BinanceOrderSide BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_MIN = BinanceOrderMsg_BinanceOrderSide_SIDE_UNKNOWN;
const BinanceOrderMsg_BinanceOrderSide BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_MAX = BinanceOrderMsg_BinanceOrderSide_SELL;
const int BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_ARRAYSIZE = BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinanceOrderMsg_BinanceOrderSide_descriptor();
inline const ::std::string& BinanceOrderMsg_BinanceOrderSide_Name(BinanceOrderMsg_BinanceOrderSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinanceOrderMsg_BinanceOrderSide_descriptor(), value);
}
inline bool BinanceOrderMsg_BinanceOrderSide_Parse(
    const ::std::string& name, BinanceOrderMsg_BinanceOrderSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinanceOrderMsg_BinanceOrderSide>(
    BinanceOrderMsg_BinanceOrderSide_descriptor(), name, value);
}
enum BinanceOrderMsg_BinanceTimeInForce {
  BinanceOrderMsg_BinanceTimeInForce_TIF_UNKNOWN = 0,
  BinanceOrderMsg_BinanceTimeInForce_GTE = 1,
  BinanceOrderMsg_BinanceTimeInForce_TIF_RESERVED = 2,
  BinanceOrderMsg_BinanceTimeInForce_IOC = 3
};
bool BinanceOrderMsg_BinanceTimeInForce_IsValid(int value);
const BinanceOrderMsg_BinanceTimeInForce BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_MIN = BinanceOrderMsg_BinanceTimeInForce_TIF_UNKNOWN;
const BinanceOrderMsg_BinanceTimeInForce BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_MAX = BinanceOrderMsg_BinanceTimeInForce_IOC;
const int BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_ARRAYSIZE = BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinanceOrderMsg_BinanceTimeInForce_descriptor();
inline const ::std::string& BinanceOrderMsg_BinanceTimeInForce_Name(BinanceOrderMsg_BinanceTimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinanceOrderMsg_BinanceTimeInForce_descriptor(), value);
}
inline bool BinanceOrderMsg_BinanceTimeInForce_Parse(
    const ::std::string& name, BinanceOrderMsg_BinanceTimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinanceOrderMsg_BinanceTimeInForce>(
    BinanceOrderMsg_BinanceTimeInForce_descriptor(), name, value);
}
// ===================================================================

class BinanceGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceGetAddress) */ {
 public:
  BinanceGetAddress();
  virtual ~BinanceGetAddress();

  BinanceGetAddress(const BinanceGetAddress& from);

  inline BinanceGetAddress& operator=(const BinanceGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceGetAddress(BinanceGetAddress&& from) noexcept
    : BinanceGetAddress() {
    *this = ::std::move(from);
  }

  inline BinanceGetAddress& operator=(BinanceGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceGetAddress* internal_default_instance() {
    return reinterpret_cast<const BinanceGetAddress*>(
               &_BinanceGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BinanceGetAddress* other);
  friend void swap(BinanceGetAddress& a, BinanceGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceGetAddress* New() const final {
    return CreateMaybeMessage<BinanceGetAddress>(nullptr);
  }

  BinanceGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceGetAddress& from);
  void MergeFrom(const BinanceGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceAddress) */ {
 public:
  BinanceAddress();
  virtual ~BinanceAddress();

  BinanceAddress(const BinanceAddress& from);

  inline BinanceAddress& operator=(const BinanceAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceAddress(BinanceAddress&& from) noexcept
    : BinanceAddress() {
    *this = ::std::move(from);
  }

  inline BinanceAddress& operator=(BinanceAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceAddress* internal_default_instance() {
    return reinterpret_cast<const BinanceAddress*>(
               &_BinanceAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BinanceAddress* other);
  friend void swap(BinanceAddress& a, BinanceAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceAddress* New() const final {
    return CreateMaybeMessage<BinanceAddress>(nullptr);
  }

  BinanceAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceAddress& from);
  void MergeFrom(const BinanceAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceGetPublicKey) */ {
 public:
  BinanceGetPublicKey();
  virtual ~BinanceGetPublicKey();

  BinanceGetPublicKey(const BinanceGetPublicKey& from);

  inline BinanceGetPublicKey& operator=(const BinanceGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceGetPublicKey(BinanceGetPublicKey&& from) noexcept
    : BinanceGetPublicKey() {
    *this = ::std::move(from);
  }

  inline BinanceGetPublicKey& operator=(BinanceGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const BinanceGetPublicKey*>(
               &_BinanceGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BinanceGetPublicKey* other);
  friend void swap(BinanceGetPublicKey& a, BinanceGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceGetPublicKey* New() const final {
    return CreateMaybeMessage<BinanceGetPublicKey>(nullptr);
  }

  BinanceGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceGetPublicKey& from);
  void MergeFrom(const BinanceGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinancePublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinancePublicKey) */ {
 public:
  BinancePublicKey();
  virtual ~BinancePublicKey();

  BinancePublicKey(const BinancePublicKey& from);

  inline BinancePublicKey& operator=(const BinancePublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinancePublicKey(BinancePublicKey&& from) noexcept
    : BinancePublicKey() {
    *this = ::std::move(from);
  }

  inline BinancePublicKey& operator=(BinancePublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinancePublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinancePublicKey* internal_default_instance() {
    return reinterpret_cast<const BinancePublicKey*>(
               &_BinancePublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BinancePublicKey* other);
  friend void swap(BinancePublicKey& a, BinancePublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinancePublicKey* New() const final {
    return CreateMaybeMessage<BinancePublicKey>(nullptr);
  }

  BinancePublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinancePublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinancePublicKey& from);
  void MergeFrom(const BinancePublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinancePublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinancePublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceSignTx) */ {
 public:
  BinanceSignTx();
  virtual ~BinanceSignTx();

  BinanceSignTx(const BinanceSignTx& from);

  inline BinanceSignTx& operator=(const BinanceSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSignTx(BinanceSignTx&& from) noexcept
    : BinanceSignTx() {
    *this = ::std::move(from);
  }

  inline BinanceSignTx& operator=(BinanceSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSignTx* internal_default_instance() {
    return reinterpret_cast<const BinanceSignTx*>(
               &_BinanceSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BinanceSignTx* other);
  friend void swap(BinanceSignTx& a, BinanceSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSignTx* New() const final {
    return CreateMaybeMessage<BinanceSignTx>(nullptr);
  }

  BinanceSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSignTx& from);
  void MergeFrom(const BinanceSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string chain_id = 4;
  bool has_chain_id() const;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 4;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // optional string memo = 5;
  bool has_memo() const;
  void clear_memo();
  static const int kMemoFieldNumber = 5;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // optional sint64 account_number = 3;
  bool has_account_number() const;
  void clear_account_number();
  static const int kAccountNumberFieldNumber = 3;
  ::google::protobuf::int64 account_number() const;
  void set_account_number(::google::protobuf::int64 value);

  // optional sint64 sequence = 6;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 6;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // optional sint64 source = 7;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 7;
  ::google::protobuf::int64 source() const;
  void set_source(::google::protobuf::int64 value);

  // optional uint32 msg_count = 2;
  bool has_msg_count() const;
  void clear_msg_count();
  static const int kMsgCountFieldNumber = 2;
  ::google::protobuf::uint32 msg_count() const;
  void set_msg_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::google::protobuf::int64 account_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 source_;
  ::google::protobuf::uint32 msg_count_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceTxRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceTxRequest) */ {
 public:
  BinanceTxRequest();
  virtual ~BinanceTxRequest();

  BinanceTxRequest(const BinanceTxRequest& from);

  inline BinanceTxRequest& operator=(const BinanceTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTxRequest(BinanceTxRequest&& from) noexcept
    : BinanceTxRequest() {
    *this = ::std::move(from);
  }

  inline BinanceTxRequest& operator=(BinanceTxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceTxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTxRequest* internal_default_instance() {
    return reinterpret_cast<const BinanceTxRequest*>(
               &_BinanceTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BinanceTxRequest* other);
  friend void swap(BinanceTxRequest& a, BinanceTxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTxRequest* New() const final {
    return CreateMaybeMessage<BinanceTxRequest>(nullptr);
  }

  BinanceTxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTxRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTxRequest& from);
  void MergeFrom(const BinanceTxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceTxRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceTransferMsg_BinanceInputOutput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput) */ {
 public:
  BinanceTransferMsg_BinanceInputOutput();
  virtual ~BinanceTransferMsg_BinanceInputOutput();

  BinanceTransferMsg_BinanceInputOutput(const BinanceTransferMsg_BinanceInputOutput& from);

  inline BinanceTransferMsg_BinanceInputOutput& operator=(const BinanceTransferMsg_BinanceInputOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTransferMsg_BinanceInputOutput(BinanceTransferMsg_BinanceInputOutput&& from) noexcept
    : BinanceTransferMsg_BinanceInputOutput() {
    *this = ::std::move(from);
  }

  inline BinanceTransferMsg_BinanceInputOutput& operator=(BinanceTransferMsg_BinanceInputOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceTransferMsg_BinanceInputOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTransferMsg_BinanceInputOutput* internal_default_instance() {
    return reinterpret_cast<const BinanceTransferMsg_BinanceInputOutput*>(
               &_BinanceTransferMsg_BinanceInputOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BinanceTransferMsg_BinanceInputOutput* other);
  friend void swap(BinanceTransferMsg_BinanceInputOutput& a, BinanceTransferMsg_BinanceInputOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTransferMsg_BinanceInputOutput* New() const final {
    return CreateMaybeMessage<BinanceTransferMsg_BinanceInputOutput>(nullptr);
  }

  BinanceTransferMsg_BinanceInputOutput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTransferMsg_BinanceInputOutput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTransferMsg_BinanceInputOutput& from);
  void MergeFrom(const BinanceTransferMsg_BinanceInputOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTransferMsg_BinanceInputOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin coins = 2;
  int coins_size() const;
  void clear_coins();
  static const int kCoinsFieldNumber = 2;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin* mutable_coins(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin >*
      mutable_coins();
  const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin& coins(int index) const;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin* add_coins();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin >&
      coins() const;

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin > coins_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceTransferMsg_BinanceCoin final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin) */ {
 public:
  BinanceTransferMsg_BinanceCoin();
  virtual ~BinanceTransferMsg_BinanceCoin();

  BinanceTransferMsg_BinanceCoin(const BinanceTransferMsg_BinanceCoin& from);

  inline BinanceTransferMsg_BinanceCoin& operator=(const BinanceTransferMsg_BinanceCoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTransferMsg_BinanceCoin(BinanceTransferMsg_BinanceCoin&& from) noexcept
    : BinanceTransferMsg_BinanceCoin() {
    *this = ::std::move(from);
  }

  inline BinanceTransferMsg_BinanceCoin& operator=(BinanceTransferMsg_BinanceCoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceTransferMsg_BinanceCoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTransferMsg_BinanceCoin* internal_default_instance() {
    return reinterpret_cast<const BinanceTransferMsg_BinanceCoin*>(
               &_BinanceTransferMsg_BinanceCoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BinanceTransferMsg_BinanceCoin* other);
  friend void swap(BinanceTransferMsg_BinanceCoin& a, BinanceTransferMsg_BinanceCoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTransferMsg_BinanceCoin* New() const final {
    return CreateMaybeMessage<BinanceTransferMsg_BinanceCoin>(nullptr);
  }

  BinanceTransferMsg_BinanceCoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTransferMsg_BinanceCoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTransferMsg_BinanceCoin& from);
  void MergeFrom(const BinanceTransferMsg_BinanceCoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTransferMsg_BinanceCoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string denom = 2;
  bool has_denom() const;
  void clear_denom();
  static const int kDenomFieldNumber = 2;
  const ::std::string& denom() const;
  void set_denom(const ::std::string& value);
  #if LANG_CXX11
  void set_denom(::std::string&& value);
  #endif
  void set_denom(const char* value);
  void set_denom(const char* value, size_t size);
  ::std::string* mutable_denom();
  ::std::string* release_denom();
  void set_allocated_denom(::std::string* denom);

  // optional sint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr denom_;
  ::google::protobuf::int64 amount_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceTransferMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceTransferMsg) */ {
 public:
  BinanceTransferMsg();
  virtual ~BinanceTransferMsg();

  BinanceTransferMsg(const BinanceTransferMsg& from);

  inline BinanceTransferMsg& operator=(const BinanceTransferMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTransferMsg(BinanceTransferMsg&& from) noexcept
    : BinanceTransferMsg() {
    *this = ::std::move(from);
  }

  inline BinanceTransferMsg& operator=(BinanceTransferMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceTransferMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTransferMsg* internal_default_instance() {
    return reinterpret_cast<const BinanceTransferMsg*>(
               &_BinanceTransferMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BinanceTransferMsg* other);
  friend void swap(BinanceTransferMsg& a, BinanceTransferMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTransferMsg* New() const final {
    return CreateMaybeMessage<BinanceTransferMsg>(nullptr);
  }

  BinanceTransferMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTransferMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTransferMsg& from);
  void MergeFrom(const BinanceTransferMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTransferMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BinanceTransferMsg_BinanceInputOutput BinanceInputOutput;
  typedef BinanceTransferMsg_BinanceCoin BinanceCoin;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >*
      mutable_inputs();
  const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput& inputs(int index) const;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >&
      inputs() const;

  // repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >*
      mutable_outputs();
  const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput& outputs(int index) const;
  ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceTransferMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput > outputs_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceOrderMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceOrderMsg) */ {
 public:
  BinanceOrderMsg();
  virtual ~BinanceOrderMsg();

  BinanceOrderMsg(const BinanceOrderMsg& from);

  inline BinanceOrderMsg& operator=(const BinanceOrderMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceOrderMsg(BinanceOrderMsg&& from) noexcept
    : BinanceOrderMsg() {
    *this = ::std::move(from);
  }

  inline BinanceOrderMsg& operator=(BinanceOrderMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceOrderMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceOrderMsg* internal_default_instance() {
    return reinterpret_cast<const BinanceOrderMsg*>(
               &_BinanceOrderMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BinanceOrderMsg* other);
  friend void swap(BinanceOrderMsg& a, BinanceOrderMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceOrderMsg* New() const final {
    return CreateMaybeMessage<BinanceOrderMsg>(nullptr);
  }

  BinanceOrderMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceOrderMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceOrderMsg& from);
  void MergeFrom(const BinanceOrderMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceOrderMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BinanceOrderMsg_BinanceOrderType BinanceOrderType;
  static const BinanceOrderType OT_UNKNOWN =
    BinanceOrderMsg_BinanceOrderType_OT_UNKNOWN;
  static const BinanceOrderType MARKET =
    BinanceOrderMsg_BinanceOrderType_MARKET;
  static const BinanceOrderType LIMIT =
    BinanceOrderMsg_BinanceOrderType_LIMIT;
  static const BinanceOrderType OT_RESERVED =
    BinanceOrderMsg_BinanceOrderType_OT_RESERVED;
  static inline bool BinanceOrderType_IsValid(int value) {
    return BinanceOrderMsg_BinanceOrderType_IsValid(value);
  }
  static const BinanceOrderType BinanceOrderType_MIN =
    BinanceOrderMsg_BinanceOrderType_BinanceOrderType_MIN;
  static const BinanceOrderType BinanceOrderType_MAX =
    BinanceOrderMsg_BinanceOrderType_BinanceOrderType_MAX;
  static const int BinanceOrderType_ARRAYSIZE =
    BinanceOrderMsg_BinanceOrderType_BinanceOrderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BinanceOrderType_descriptor() {
    return BinanceOrderMsg_BinanceOrderType_descriptor();
  }
  static inline const ::std::string& BinanceOrderType_Name(BinanceOrderType value) {
    return BinanceOrderMsg_BinanceOrderType_Name(value);
  }
  static inline bool BinanceOrderType_Parse(const ::std::string& name,
      BinanceOrderType* value) {
    return BinanceOrderMsg_BinanceOrderType_Parse(name, value);
  }

  typedef BinanceOrderMsg_BinanceOrderSide BinanceOrderSide;
  static const BinanceOrderSide SIDE_UNKNOWN =
    BinanceOrderMsg_BinanceOrderSide_SIDE_UNKNOWN;
  static const BinanceOrderSide BUY =
    BinanceOrderMsg_BinanceOrderSide_BUY;
  static const BinanceOrderSide SELL =
    BinanceOrderMsg_BinanceOrderSide_SELL;
  static inline bool BinanceOrderSide_IsValid(int value) {
    return BinanceOrderMsg_BinanceOrderSide_IsValid(value);
  }
  static const BinanceOrderSide BinanceOrderSide_MIN =
    BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_MIN;
  static const BinanceOrderSide BinanceOrderSide_MAX =
    BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_MAX;
  static const int BinanceOrderSide_ARRAYSIZE =
    BinanceOrderMsg_BinanceOrderSide_BinanceOrderSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BinanceOrderSide_descriptor() {
    return BinanceOrderMsg_BinanceOrderSide_descriptor();
  }
  static inline const ::std::string& BinanceOrderSide_Name(BinanceOrderSide value) {
    return BinanceOrderMsg_BinanceOrderSide_Name(value);
  }
  static inline bool BinanceOrderSide_Parse(const ::std::string& name,
      BinanceOrderSide* value) {
    return BinanceOrderMsg_BinanceOrderSide_Parse(name, value);
  }

  typedef BinanceOrderMsg_BinanceTimeInForce BinanceTimeInForce;
  static const BinanceTimeInForce TIF_UNKNOWN =
    BinanceOrderMsg_BinanceTimeInForce_TIF_UNKNOWN;
  static const BinanceTimeInForce GTE =
    BinanceOrderMsg_BinanceTimeInForce_GTE;
  static const BinanceTimeInForce TIF_RESERVED =
    BinanceOrderMsg_BinanceTimeInForce_TIF_RESERVED;
  static const BinanceTimeInForce IOC =
    BinanceOrderMsg_BinanceTimeInForce_IOC;
  static inline bool BinanceTimeInForce_IsValid(int value) {
    return BinanceOrderMsg_BinanceTimeInForce_IsValid(value);
  }
  static const BinanceTimeInForce BinanceTimeInForce_MIN =
    BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_MIN;
  static const BinanceTimeInForce BinanceTimeInForce_MAX =
    BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_MAX;
  static const int BinanceTimeInForce_ARRAYSIZE =
    BinanceOrderMsg_BinanceTimeInForce_BinanceTimeInForce_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BinanceTimeInForce_descriptor() {
    return BinanceOrderMsg_BinanceTimeInForce_descriptor();
  }
  static inline const ::std::string& BinanceTimeInForce_Name(BinanceTimeInForce value) {
    return BinanceOrderMsg_BinanceTimeInForce_Name(value);
  }
  static inline bool BinanceTimeInForce_Parse(const ::std::string& name,
      BinanceTimeInForce* value) {
    return BinanceOrderMsg_BinanceTimeInForce_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string sender = 5;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 5;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // optional string symbol = 7;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 7;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional sint64 price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  ::google::protobuf::int64 price() const;
  void set_price(::google::protobuf::int64 value);

  // optional sint64 quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  ::google::protobuf::int64 quantity() const;
  void set_quantity(::google::protobuf::int64 value);

  // optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceOrderType ordertype = 2;
  bool has_ordertype() const;
  void clear_ordertype();
  static const int kOrdertypeFieldNumber = 2;
  ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType ordertype() const;
  void set_ordertype(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType value);

  // optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceOrderSide side = 6;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 6;
  ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide side() const;
  void set_side(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide value);

  // optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceTimeInForce timeinforce = 8;
  bool has_timeinforce() const;
  void clear_timeinforce();
  static const int kTimeinforceFieldNumber = 8;
  ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce timeinforce() const;
  void set_timeinforce(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceOrderMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int64 quantity_;
  int ordertype_;
  int side_;
  int timeinforce_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceCancelMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceCancelMsg) */ {
 public:
  BinanceCancelMsg();
  virtual ~BinanceCancelMsg();

  BinanceCancelMsg(const BinanceCancelMsg& from);

  inline BinanceCancelMsg& operator=(const BinanceCancelMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceCancelMsg(BinanceCancelMsg&& from) noexcept
    : BinanceCancelMsg() {
    *this = ::std::move(from);
  }

  inline BinanceCancelMsg& operator=(BinanceCancelMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceCancelMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceCancelMsg* internal_default_instance() {
    return reinterpret_cast<const BinanceCancelMsg*>(
               &_BinanceCancelMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BinanceCancelMsg* other);
  friend void swap(BinanceCancelMsg& a, BinanceCancelMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceCancelMsg* New() const final {
    return CreateMaybeMessage<BinanceCancelMsg>(nullptr);
  }

  BinanceCancelMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceCancelMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceCancelMsg& from);
  void MergeFrom(const BinanceCancelMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceCancelMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string refid = 1;
  bool has_refid() const;
  void clear_refid();
  static const int kRefidFieldNumber = 1;
  const ::std::string& refid() const;
  void set_refid(const ::std::string& value);
  #if LANG_CXX11
  void set_refid(::std::string&& value);
  #endif
  void set_refid(const char* value);
  void set_refid(const char* value, size_t size);
  ::std::string* mutable_refid();
  ::std::string* release_refid();
  void set_allocated_refid(::std::string* refid);

  // optional string sender = 2;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 2;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // optional string symbol = 3;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceCancelMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr refid_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// -------------------------------------------------------------------

class BinanceSignedTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.binance.BinanceSignedTx) */ {
 public:
  BinanceSignedTx();
  virtual ~BinanceSignedTx();

  BinanceSignedTx(const BinanceSignedTx& from);

  inline BinanceSignedTx& operator=(const BinanceSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSignedTx(BinanceSignedTx&& from) noexcept
    : BinanceSignedTx() {
    *this = ::std::move(from);
  }

  inline BinanceSignedTx& operator=(BinanceSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinanceSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSignedTx* internal_default_instance() {
    return reinterpret_cast<const BinanceSignedTx*>(
               &_BinanceSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BinanceSignedTx* other);
  friend void swap(BinanceSignedTx& a, BinanceSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSignedTx* New() const final {
    return CreateMaybeMessage<BinanceSignedTx>(nullptr);
  }

  BinanceSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSignedTx& from);
  void MergeFrom(const BinanceSignedTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.binance.BinanceSignedTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_messages_2dbinance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BinanceGetAddress

// repeated uint32 address_n = 1;
inline int BinanceGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void BinanceGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 BinanceGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceGetAddress.address_n)
  return address_n_.Get(index);
}
inline void BinanceGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceGetAddress.address_n)
}
inline void BinanceGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BinanceGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BinanceGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool BinanceGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BinanceGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceGetAddress.show_display)
  return show_display_;
}
inline void BinanceGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceGetAddress.show_display)
}

// -------------------------------------------------------------------

// BinanceAddress

// optional string address = 1;
inline bool BinanceAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceAddress.address)
  return address_.GetNoArena();
}
inline void BinanceAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceAddress.address)
}
#if LANG_CXX11
inline void BinanceAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceAddress.address)
}
#endif
inline void BinanceAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceAddress.address)
}
inline void BinanceAddress::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceAddress.address)
}
inline ::std::string* BinanceAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceAddress.address)
}

// -------------------------------------------------------------------

// BinanceGetPublicKey

// repeated uint32 address_n = 1;
inline int BinanceGetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void BinanceGetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 BinanceGetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceGetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void BinanceGetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceGetPublicKey.address_n)
}
inline void BinanceGetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceGetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BinanceGetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceGetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BinanceGetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceGetPublicKey.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool BinanceGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BinanceGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceGetPublicKey.show_display)
  return show_display_;
}
inline void BinanceGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// BinancePublicKey

// optional bytes public_key = 1;
inline bool BinancePublicKey::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinancePublicKey::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinancePublicKey::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinancePublicKey.public_key)
  return public_key_.GetNoArena();
}
inline void BinancePublicKey::set_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinancePublicKey.public_key)
}
#if LANG_CXX11
inline void BinancePublicKey::set_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinancePublicKey.public_key)
}
#endif
inline void BinancePublicKey::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinancePublicKey.public_key)
}
inline void BinancePublicKey::set_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinancePublicKey.public_key)
}
inline ::std::string* BinancePublicKey::mutable_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinancePublicKey.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinancePublicKey::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinancePublicKey.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinancePublicKey::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinancePublicKey.public_key)
}

// -------------------------------------------------------------------

// BinanceSignTx

// repeated uint32 address_n = 1;
inline int BinanceSignTx::address_n_size() const {
  return address_n_.size();
}
inline void BinanceSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 BinanceSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.address_n)
  return address_n_.Get(index);
}
inline void BinanceSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.address_n)
}
inline void BinanceSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BinanceSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BinanceSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceSignTx.address_n)
  return &address_n_;
}

// optional uint32 msg_count = 2;
inline bool BinanceSignTx::has_msg_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BinanceSignTx::clear_msg_count() {
  msg_count_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 BinanceSignTx::msg_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.msg_count)
  return msg_count_;
}
inline void BinanceSignTx::set_msg_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  msg_count_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.msg_count)
}

// optional sint64 account_number = 3;
inline bool BinanceSignTx::has_account_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinanceSignTx::clear_account_number() {
  account_number_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 BinanceSignTx::account_number() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.account_number)
  return account_number_;
}
inline void BinanceSignTx::set_account_number(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  account_number_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.account_number)
}

// optional string chain_id = 4;
inline bool BinanceSignTx::has_chain_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceSignTx::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceSignTx::chain_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.chain_id)
  return chain_id_.GetNoArena();
}
inline void BinanceSignTx::set_chain_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.chain_id)
}
#if LANG_CXX11
inline void BinanceSignTx::set_chain_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceSignTx.chain_id)
}
#endif
inline void BinanceSignTx::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceSignTx.chain_id)
}
inline void BinanceSignTx::set_chain_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceSignTx.chain_id)
}
inline ::std::string* BinanceSignTx::mutable_chain_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceSignTx.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignTx::release_chain_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceSignTx.chain_id)
  if (!has_chain_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chain_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignTx::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceSignTx.chain_id)
}

// optional string memo = 5;
inline bool BinanceSignTx::has_memo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinanceSignTx::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BinanceSignTx::memo() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.memo)
  return memo_.GetNoArena();
}
inline void BinanceSignTx::set_memo(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.memo)
}
#if LANG_CXX11
inline void BinanceSignTx::set_memo(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceSignTx.memo)
}
#endif
inline void BinanceSignTx::set_memo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceSignTx.memo)
}
inline void BinanceSignTx::set_memo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceSignTx.memo)
}
inline ::std::string* BinanceSignTx::mutable_memo() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceSignTx.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignTx::release_memo() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceSignTx.memo)
  if (!has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return memo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignTx::set_allocated_memo(::std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceSignTx.memo)
}

// optional sint64 sequence = 6;
inline bool BinanceSignTx::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinanceSignTx::clear_sequence() {
  sequence_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int64 BinanceSignTx::sequence() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.sequence)
  return sequence_;
}
inline void BinanceSignTx::set_sequence(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  sequence_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.sequence)
}

// optional sint64 source = 7;
inline bool BinanceSignTx::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BinanceSignTx::clear_source() {
  source_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 BinanceSignTx::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignTx.source)
  return source_;
}
inline void BinanceSignTx::set_source(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  source_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignTx.source)
}

// -------------------------------------------------------------------

// BinanceTxRequest

// -------------------------------------------------------------------

// BinanceTransferMsg_BinanceInputOutput

// optional string address = 1;
inline bool BinanceTransferMsg_BinanceInputOutput::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceTransferMsg_BinanceInputOutput::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceTransferMsg_BinanceInputOutput::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
  return address_.GetNoArena();
}
inline void BinanceTransferMsg_BinanceInputOutput::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
}
#if LANG_CXX11
inline void BinanceTransferMsg_BinanceInputOutput::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
}
#endif
inline void BinanceTransferMsg_BinanceInputOutput::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
}
inline void BinanceTransferMsg_BinanceInputOutput::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
}
inline ::std::string* BinanceTransferMsg_BinanceInputOutput::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTransferMsg_BinanceInputOutput::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTransferMsg_BinanceInputOutput::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.address)
}

// repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin coins = 2;
inline int BinanceTransferMsg_BinanceInputOutput::coins_size() const {
  return coins_.size();
}
inline void BinanceTransferMsg_BinanceInputOutput::clear_coins() {
  coins_.Clear();
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin* BinanceTransferMsg_BinanceInputOutput::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.coins)
  return coins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin >*
BinanceTransferMsg_BinanceInputOutput::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.coins)
  return &coins_;
}
inline const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin& BinanceTransferMsg_BinanceInputOutput::coins(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.coins)
  return coins_.Get(index);
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin* BinanceTransferMsg_BinanceInputOutput::add_coins() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.coins)
  return coins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceCoin >&
BinanceTransferMsg_BinanceInputOutput::coins() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput.coins)
  return coins_;
}

// -------------------------------------------------------------------

// BinanceTransferMsg_BinanceCoin

// optional sint64 amount = 1;
inline bool BinanceTransferMsg_BinanceCoin::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinanceTransferMsg_BinanceCoin::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 BinanceTransferMsg_BinanceCoin::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.amount)
  return amount_;
}
inline void BinanceTransferMsg_BinanceCoin::set_amount(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.amount)
}

// optional string denom = 2;
inline bool BinanceTransferMsg_BinanceCoin::has_denom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceTransferMsg_BinanceCoin::clear_denom() {
  denom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceTransferMsg_BinanceCoin::denom() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
  return denom_.GetNoArena();
}
inline void BinanceTransferMsg_BinanceCoin::set_denom(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
}
#if LANG_CXX11
inline void BinanceTransferMsg_BinanceCoin::set_denom(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  denom_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
}
#endif
inline void BinanceTransferMsg_BinanceCoin::set_denom(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
}
inline void BinanceTransferMsg_BinanceCoin::set_denom(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
}
inline ::std::string* BinanceTransferMsg_BinanceCoin::mutable_denom() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
  return denom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTransferMsg_BinanceCoin::release_denom() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
  if (!has_denom()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return denom_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTransferMsg_BinanceCoin::set_allocated_denom(::std::string* denom) {
  if (denom != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  denom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), denom);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceTransferMsg.BinanceCoin.denom)
}

// -------------------------------------------------------------------

// BinanceTransferMsg

// repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput inputs = 1;
inline int BinanceTransferMsg::inputs_size() const {
  return inputs_.size();
}
inline void BinanceTransferMsg::clear_inputs() {
  inputs_.Clear();
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* BinanceTransferMsg::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceTransferMsg.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >*
BinanceTransferMsg::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceTransferMsg.inputs)
  return &inputs_;
}
inline const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput& BinanceTransferMsg::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.inputs)
  return inputs_.Get(index);
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* BinanceTransferMsg::add_inputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceTransferMsg.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >&
BinanceTransferMsg::inputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceTransferMsg.inputs)
  return inputs_;
}

// repeated .hw.trezor.messages.binance.BinanceTransferMsg.BinanceInputOutput outputs = 2;
inline int BinanceTransferMsg::outputs_size() const {
  return outputs_.size();
}
inline void BinanceTransferMsg::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* BinanceTransferMsg::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceTransferMsg.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >*
BinanceTransferMsg::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.binance.BinanceTransferMsg.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput& BinanceTransferMsg::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceTransferMsg.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput* BinanceTransferMsg::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.binance.BinanceTransferMsg.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::binance::BinanceTransferMsg_BinanceInputOutput >&
BinanceTransferMsg::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.binance.BinanceTransferMsg.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// BinanceOrderMsg

// optional string id = 1;
inline bool BinanceOrderMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceOrderMsg::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceOrderMsg::id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.id)
  return id_.GetNoArena();
}
inline void BinanceOrderMsg::set_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.id)
}
#if LANG_CXX11
inline void BinanceOrderMsg::set_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceOrderMsg.id)
}
#endif
inline void BinanceOrderMsg::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceOrderMsg.id)
}
inline void BinanceOrderMsg::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceOrderMsg.id)
}
inline ::std::string* BinanceOrderMsg::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceOrderMsg.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceOrderMsg::release_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceOrderMsg.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceOrderMsg::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceOrderMsg.id)
}

// optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceOrderType ordertype = 2;
inline bool BinanceOrderMsg::has_ordertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BinanceOrderMsg::clear_ordertype() {
  ordertype_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType BinanceOrderMsg::ordertype() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.ordertype)
  return static_cast< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType >(ordertype_);
}
inline void BinanceOrderMsg::set_ordertype(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType value) {
  assert(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.ordertype)
}

// optional sint64 price = 3;
inline bool BinanceOrderMsg::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinanceOrderMsg::clear_price() {
  price_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int64 BinanceOrderMsg::price() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.price)
  return price_;
}
inline void BinanceOrderMsg::set_price(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  price_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.price)
}

// optional sint64 quantity = 4;
inline bool BinanceOrderMsg::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BinanceOrderMsg::clear_quantity() {
  quantity_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 BinanceOrderMsg::quantity() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.quantity)
  return quantity_;
}
inline void BinanceOrderMsg::set_quantity(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  quantity_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.quantity)
}

// optional string sender = 5;
inline bool BinanceOrderMsg::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinanceOrderMsg::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BinanceOrderMsg::sender() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.sender)
  return sender_.GetNoArena();
}
inline void BinanceOrderMsg::set_sender(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.sender)
}
#if LANG_CXX11
inline void BinanceOrderMsg::set_sender(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceOrderMsg.sender)
}
#endif
inline void BinanceOrderMsg::set_sender(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceOrderMsg.sender)
}
inline void BinanceOrderMsg::set_sender(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceOrderMsg.sender)
}
inline ::std::string* BinanceOrderMsg::mutable_sender() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceOrderMsg.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceOrderMsg::release_sender() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceOrderMsg.sender)
  if (!has_sender()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sender_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceOrderMsg::set_allocated_sender(::std::string* sender) {
  if (sender != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceOrderMsg.sender)
}

// optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceOrderSide side = 6;
inline bool BinanceOrderMsg::has_side() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BinanceOrderMsg::clear_side() {
  side_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide BinanceOrderMsg::side() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.side)
  return static_cast< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide >(side_);
}
inline void BinanceOrderMsg::set_side(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide value) {
  assert(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  side_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.side)
}

// optional string symbol = 7;
inline bool BinanceOrderMsg::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinanceOrderMsg::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BinanceOrderMsg::symbol() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceOrderMsg::set_symbol(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
}
#if LANG_CXX11
inline void BinanceOrderMsg::set_symbol(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
}
#endif
inline void BinanceOrderMsg::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
}
inline void BinanceOrderMsg::set_symbol(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
}
inline ::std::string* BinanceOrderMsg::mutable_symbol() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceOrderMsg::release_symbol() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
  if (!has_symbol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceOrderMsg::set_allocated_symbol(::std::string* symbol) {
  if (symbol != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceOrderMsg.symbol)
}

// optional .hw.trezor.messages.binance.BinanceOrderMsg.BinanceTimeInForce timeinforce = 8;
inline bool BinanceOrderMsg::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BinanceOrderMsg::clear_timeinforce() {
  timeinforce_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce BinanceOrderMsg::timeinforce() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceOrderMsg.timeinforce)
  return static_cast< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce >(timeinforce_);
}
inline void BinanceOrderMsg::set_timeinforce(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce value) {
  assert(::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceOrderMsg.timeinforce)
}

// -------------------------------------------------------------------

// BinanceCancelMsg

// optional string refid = 1;
inline bool BinanceCancelMsg::has_refid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceCancelMsg::clear_refid() {
  refid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceCancelMsg::refid() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceCancelMsg.refid)
  return refid_.GetNoArena();
}
inline void BinanceCancelMsg::set_refid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceCancelMsg.refid)
}
#if LANG_CXX11
inline void BinanceCancelMsg::set_refid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  refid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceCancelMsg.refid)
}
#endif
inline void BinanceCancelMsg::set_refid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceCancelMsg.refid)
}
inline void BinanceCancelMsg::set_refid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceCancelMsg.refid)
}
inline ::std::string* BinanceCancelMsg::mutable_refid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceCancelMsg.refid)
  return refid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelMsg::release_refid() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceCancelMsg.refid)
  if (!has_refid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return refid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelMsg::set_allocated_refid(::std::string* refid) {
  if (refid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  refid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refid);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceCancelMsg.refid)
}

// optional string sender = 2;
inline bool BinanceCancelMsg::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinanceCancelMsg::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BinanceCancelMsg::sender() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceCancelMsg.sender)
  return sender_.GetNoArena();
}
inline void BinanceCancelMsg::set_sender(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceCancelMsg.sender)
}
#if LANG_CXX11
inline void BinanceCancelMsg::set_sender(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceCancelMsg.sender)
}
#endif
inline void BinanceCancelMsg::set_sender(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceCancelMsg.sender)
}
inline void BinanceCancelMsg::set_sender(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceCancelMsg.sender)
}
inline ::std::string* BinanceCancelMsg::mutable_sender() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceCancelMsg.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelMsg::release_sender() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceCancelMsg.sender)
  if (!has_sender()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sender_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelMsg::set_allocated_sender(::std::string* sender) {
  if (sender != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceCancelMsg.sender)
}

// optional string symbol = 3;
inline bool BinanceCancelMsg::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinanceCancelMsg::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BinanceCancelMsg::symbol() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceCancelMsg::set_symbol(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
}
#if LANG_CXX11
inline void BinanceCancelMsg::set_symbol(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
}
#endif
inline void BinanceCancelMsg::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
}
inline void BinanceCancelMsg::set_symbol(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
}
inline ::std::string* BinanceCancelMsg::mutable_symbol() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelMsg::release_symbol() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
  if (!has_symbol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return symbol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelMsg::set_allocated_symbol(::std::string* symbol) {
  if (symbol != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceCancelMsg.symbol)
}

// -------------------------------------------------------------------

// BinanceSignedTx

// optional bytes signature = 1;
inline bool BinanceSignedTx::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinanceSignedTx::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinanceSignedTx::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignedTx.signature)
  return signature_.GetNoArena();
}
inline void BinanceSignedTx::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignedTx.signature)
}
#if LANG_CXX11
inline void BinanceSignedTx::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceSignedTx.signature)
}
#endif
inline void BinanceSignedTx::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceSignedTx.signature)
}
inline void BinanceSignedTx::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceSignedTx.signature)
}
inline ::std::string* BinanceSignedTx::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceSignedTx.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignedTx::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceSignedTx.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignedTx::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceSignedTx.signature)
}

// optional bytes public_key = 2;
inline bool BinanceSignedTx::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinanceSignedTx::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BinanceSignedTx::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.binance.BinanceSignedTx.public_key)
  return public_key_.GetNoArena();
}
inline void BinanceSignedTx::set_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.binance.BinanceSignedTx.public_key)
}
#if LANG_CXX11
inline void BinanceSignedTx::set_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.binance.BinanceSignedTx.public_key)
}
#endif
inline void BinanceSignedTx::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.binance.BinanceSignedTx.public_key)
}
inline void BinanceSignedTx::set_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.binance.BinanceSignedTx.public_key)
}
inline ::std::string* BinanceSignedTx::mutable_public_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.binance.BinanceSignedTx.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignedTx::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.binance.BinanceSignedTx.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignedTx::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.binance.BinanceSignedTx.public_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace binance
}  // namespace messages
}  // namespace trezor
}  // namespace hw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType>() {
  return ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide>() {
  return ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceOrderSide_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce>() {
  return ::hw::trezor::messages::binance::BinanceOrderMsg_BinanceTimeInForce_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dbinance_2eproto
