// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-tezos.proto

#ifndef PROTOBUF_INCLUDED_messages_2dtezos_2eproto
#define PROTOBUF_INCLUDED_messages_2dtezos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dtezos_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dtezos_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dtezos_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace tezos {
class TezosAddress;
class TezosAddressDefaultTypeInternal;
extern TezosAddressDefaultTypeInternal _TezosAddress_default_instance_;
class TezosGetAddress;
class TezosGetAddressDefaultTypeInternal;
extern TezosGetAddressDefaultTypeInternal _TezosGetAddress_default_instance_;
class TezosGetPublicKey;
class TezosGetPublicKeyDefaultTypeInternal;
extern TezosGetPublicKeyDefaultTypeInternal _TezosGetPublicKey_default_instance_;
class TezosPublicKey;
class TezosPublicKeyDefaultTypeInternal;
extern TezosPublicKeyDefaultTypeInternal _TezosPublicKey_default_instance_;
class TezosSignTx;
class TezosSignTxDefaultTypeInternal;
extern TezosSignTxDefaultTypeInternal _TezosSignTx_default_instance_;
class TezosSignTx_TezosBallotOp;
class TezosSignTx_TezosBallotOpDefaultTypeInternal;
extern TezosSignTx_TezosBallotOpDefaultTypeInternal _TezosSignTx_TezosBallotOp_default_instance_;
class TezosSignTx_TezosContractID;
class TezosSignTx_TezosContractIDDefaultTypeInternal;
extern TezosSignTx_TezosContractIDDefaultTypeInternal _TezosSignTx_TezosContractID_default_instance_;
class TezosSignTx_TezosDelegationOp;
class TezosSignTx_TezosDelegationOpDefaultTypeInternal;
extern TezosSignTx_TezosDelegationOpDefaultTypeInternal _TezosSignTx_TezosDelegationOp_default_instance_;
class TezosSignTx_TezosOriginationOp;
class TezosSignTx_TezosOriginationOpDefaultTypeInternal;
extern TezosSignTx_TezosOriginationOpDefaultTypeInternal _TezosSignTx_TezosOriginationOp_default_instance_;
class TezosSignTx_TezosProposalOp;
class TezosSignTx_TezosProposalOpDefaultTypeInternal;
extern TezosSignTx_TezosProposalOpDefaultTypeInternal _TezosSignTx_TezosProposalOp_default_instance_;
class TezosSignTx_TezosRevealOp;
class TezosSignTx_TezosRevealOpDefaultTypeInternal;
extern TezosSignTx_TezosRevealOpDefaultTypeInternal _TezosSignTx_TezosRevealOp_default_instance_;
class TezosSignTx_TezosTransactionOp;
class TezosSignTx_TezosTransactionOpDefaultTypeInternal;
extern TezosSignTx_TezosTransactionOpDefaultTypeInternal _TezosSignTx_TezosTransactionOp_default_instance_;
class TezosSignTx_TezosTransactionOp_TezosParametersManager;
class TezosSignTx_TezosTransactionOp_TezosParametersManagerDefaultTypeInternal;
extern TezosSignTx_TezosTransactionOp_TezosParametersManagerDefaultTypeInternal _TezosSignTx_TezosTransactionOp_TezosParametersManager_default_instance_;
class TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer;
class TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransferDefaultTypeInternal;
extern TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransferDefaultTypeInternal _TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer_default_instance_;
class TezosSignedTx;
class TezosSignedTxDefaultTypeInternal;
extern TezosSignedTxDefaultTypeInternal _TezosSignedTx_default_instance_;
}  // namespace tezos
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::tezos::TezosAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosAddress>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosGetAddress>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosPublicKey>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosContractID>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>(Arena*);
template<> ::hw::trezor::messages::tezos::TezosSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignedTx>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace tezos {

enum TezosSignTx_TezosContractID_TezosContractType {
  TezosSignTx_TezosContractID_TezosContractType_Implicit = 0,
  TezosSignTx_TezosContractID_TezosContractType_Originated = 1
};
bool TezosSignTx_TezosContractID_TezosContractType_IsValid(int value);
const TezosSignTx_TezosContractID_TezosContractType TezosSignTx_TezosContractID_TezosContractType_TezosContractType_MIN = TezosSignTx_TezosContractID_TezosContractType_Implicit;
const TezosSignTx_TezosContractID_TezosContractType TezosSignTx_TezosContractID_TezosContractType_TezosContractType_MAX = TezosSignTx_TezosContractID_TezosContractType_Originated;
const int TezosSignTx_TezosContractID_TezosContractType_TezosContractType_ARRAYSIZE = TezosSignTx_TezosContractID_TezosContractType_TezosContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TezosSignTx_TezosContractID_TezosContractType_descriptor();
inline const ::std::string& TezosSignTx_TezosContractID_TezosContractType_Name(TezosSignTx_TezosContractID_TezosContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TezosSignTx_TezosContractID_TezosContractType_descriptor(), value);
}
inline bool TezosSignTx_TezosContractID_TezosContractType_Parse(
    const ::std::string& name, TezosSignTx_TezosContractID_TezosContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TezosSignTx_TezosContractID_TezosContractType>(
    TezosSignTx_TezosContractID_TezosContractType_descriptor(), name, value);
}
enum TezosSignTx_TezosBallotOp_TezosBallotType {
  TezosSignTx_TezosBallotOp_TezosBallotType_Yay = 0,
  TezosSignTx_TezosBallotOp_TezosBallotType_Nay = 1,
  TezosSignTx_TezosBallotOp_TezosBallotType_Pass = 2
};
bool TezosSignTx_TezosBallotOp_TezosBallotType_IsValid(int value);
const TezosSignTx_TezosBallotOp_TezosBallotType TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_MIN = TezosSignTx_TezosBallotOp_TezosBallotType_Yay;
const TezosSignTx_TezosBallotOp_TezosBallotType TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_MAX = TezosSignTx_TezosBallotOp_TezosBallotType_Pass;
const int TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_ARRAYSIZE = TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TezosSignTx_TezosBallotOp_TezosBallotType_descriptor();
inline const ::std::string& TezosSignTx_TezosBallotOp_TezosBallotType_Name(TezosSignTx_TezosBallotOp_TezosBallotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TezosSignTx_TezosBallotOp_TezosBallotType_descriptor(), value);
}
inline bool TezosSignTx_TezosBallotOp_TezosBallotType_Parse(
    const ::std::string& name, TezosSignTx_TezosBallotOp_TezosBallotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TezosSignTx_TezosBallotOp_TezosBallotType>(
    TezosSignTx_TezosBallotOp_TezosBallotType_descriptor(), name, value);
}
// ===================================================================

class TezosGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosGetAddress) */ {
 public:
  TezosGetAddress();
  virtual ~TezosGetAddress();

  TezosGetAddress(const TezosGetAddress& from);

  inline TezosGetAddress& operator=(const TezosGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosGetAddress(TezosGetAddress&& from) noexcept
    : TezosGetAddress() {
    *this = ::std::move(from);
  }

  inline TezosGetAddress& operator=(TezosGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosGetAddress* internal_default_instance() {
    return reinterpret_cast<const TezosGetAddress*>(
               &_TezosGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TezosGetAddress* other);
  friend void swap(TezosGetAddress& a, TezosGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosGetAddress* New() const final {
    return CreateMaybeMessage<TezosGetAddress>(nullptr);
  }

  TezosGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosGetAddress& from);
  void MergeFrom(const TezosGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosAddress) */ {
 public:
  TezosAddress();
  virtual ~TezosAddress();

  TezosAddress(const TezosAddress& from);

  inline TezosAddress& operator=(const TezosAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosAddress(TezosAddress&& from) noexcept
    : TezosAddress() {
    *this = ::std::move(from);
  }

  inline TezosAddress& operator=(TezosAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosAddress* internal_default_instance() {
    return reinterpret_cast<const TezosAddress*>(
               &_TezosAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TezosAddress* other);
  friend void swap(TezosAddress& a, TezosAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosAddress* New() const final {
    return CreateMaybeMessage<TezosAddress>(nullptr);
  }

  TezosAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosAddress& from);
  void MergeFrom(const TezosAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosGetPublicKey) */ {
 public:
  TezosGetPublicKey();
  virtual ~TezosGetPublicKey();

  TezosGetPublicKey(const TezosGetPublicKey& from);

  inline TezosGetPublicKey& operator=(const TezosGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosGetPublicKey(TezosGetPublicKey&& from) noexcept
    : TezosGetPublicKey() {
    *this = ::std::move(from);
  }

  inline TezosGetPublicKey& operator=(TezosGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const TezosGetPublicKey*>(
               &_TezosGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TezosGetPublicKey* other);
  friend void swap(TezosGetPublicKey& a, TezosGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosGetPublicKey* New() const final {
    return CreateMaybeMessage<TezosGetPublicKey>(nullptr);
  }

  TezosGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosGetPublicKey& from);
  void MergeFrom(const TezosGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosPublicKey) */ {
 public:
  TezosPublicKey();
  virtual ~TezosPublicKey();

  TezosPublicKey(const TezosPublicKey& from);

  inline TezosPublicKey& operator=(const TezosPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosPublicKey(TezosPublicKey&& from) noexcept
    : TezosPublicKey() {
    *this = ::std::move(from);
  }

  inline TezosPublicKey& operator=(TezosPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosPublicKey* internal_default_instance() {
    return reinterpret_cast<const TezosPublicKey*>(
               &_TezosPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TezosPublicKey* other);
  friend void swap(TezosPublicKey& a, TezosPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosPublicKey* New() const final {
    return CreateMaybeMessage<TezosPublicKey>(nullptr);
  }

  TezosPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosPublicKey& from);
  void MergeFrom(const TezosPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosContractID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosContractID) */ {
 public:
  TezosSignTx_TezosContractID();
  virtual ~TezosSignTx_TezosContractID();

  TezosSignTx_TezosContractID(const TezosSignTx_TezosContractID& from);

  inline TezosSignTx_TezosContractID& operator=(const TezosSignTx_TezosContractID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosContractID(TezosSignTx_TezosContractID&& from) noexcept
    : TezosSignTx_TezosContractID() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosContractID& operator=(TezosSignTx_TezosContractID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosContractID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosContractID* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosContractID*>(
               &_TezosSignTx_TezosContractID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TezosSignTx_TezosContractID* other);
  friend void swap(TezosSignTx_TezosContractID& a, TezosSignTx_TezosContractID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosContractID* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosContractID>(nullptr);
  }

  TezosSignTx_TezosContractID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosContractID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosContractID& from);
  void MergeFrom(const TezosSignTx_TezosContractID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosContractID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TezosSignTx_TezosContractID_TezosContractType TezosContractType;
  static const TezosContractType Implicit =
    TezosSignTx_TezosContractID_TezosContractType_Implicit;
  static const TezosContractType Originated =
    TezosSignTx_TezosContractID_TezosContractType_Originated;
  static inline bool TezosContractType_IsValid(int value) {
    return TezosSignTx_TezosContractID_TezosContractType_IsValid(value);
  }
  static const TezosContractType TezosContractType_MIN =
    TezosSignTx_TezosContractID_TezosContractType_TezosContractType_MIN;
  static const TezosContractType TezosContractType_MAX =
    TezosSignTx_TezosContractID_TezosContractType_TezosContractType_MAX;
  static const int TezosContractType_ARRAYSIZE =
    TezosSignTx_TezosContractID_TezosContractType_TezosContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TezosContractType_descriptor() {
    return TezosSignTx_TezosContractID_TezosContractType_descriptor();
  }
  static inline const ::std::string& TezosContractType_Name(TezosContractType value) {
    return TezosSignTx_TezosContractID_TezosContractType_Name(value);
  }
  static inline bool TezosContractType_Parse(const ::std::string& name,
      TezosContractType* value) {
    return TezosSignTx_TezosContractID_TezosContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID.TezosContractType tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType tag() const;
  void set_tag(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosContractID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  int tag_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosRevealOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp) */ {
 public:
  TezosSignTx_TezosRevealOp();
  virtual ~TezosSignTx_TezosRevealOp();

  TezosSignTx_TezosRevealOp(const TezosSignTx_TezosRevealOp& from);

  inline TezosSignTx_TezosRevealOp& operator=(const TezosSignTx_TezosRevealOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosRevealOp(TezosSignTx_TezosRevealOp&& from) noexcept
    : TezosSignTx_TezosRevealOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosRevealOp& operator=(TezosSignTx_TezosRevealOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosRevealOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosRevealOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosRevealOp*>(
               &_TezosSignTx_TezosRevealOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TezosSignTx_TezosRevealOp* other);
  friend void swap(TezosSignTx_TezosRevealOp& a, TezosSignTx_TezosRevealOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosRevealOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosRevealOp>(nullptr);
  }

  TezosSignTx_TezosRevealOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosRevealOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosRevealOp& from);
  void MergeFrom(const TezosSignTx_TezosRevealOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosRevealOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_key = 6;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 6;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes source = 7;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 7;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional uint64 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 counter = 3;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 3;
  ::google::protobuf::uint64 counter() const;
  void set_counter(::google::protobuf::uint64 value);

  // optional uint64 gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // optional uint64 storage_limit = 5;
  bool has_storage_limit() const;
  void clear_storage_limit();
  static const int kStorageLimitFieldNumber = 5;
  ::google::protobuf::uint64 storage_limit() const;
  void set_storage_limit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 counter_;
  ::google::protobuf::uint64 gas_limit_;
  ::google::protobuf::uint64 storage_limit_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer) */ {
 public:
  TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer();
  virtual ~TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer();

  TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer(const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& from);

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& operator=(const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer&& from) noexcept
    : TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& operator=(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer*>(
               &_TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* other);
  friend void swap(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& a, TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>(nullptr);
  }

  TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& from);
  void MergeFrom(const TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 1;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 1;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID& destination() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* release_destination();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* mutable_destination();
  void set_allocated_destination(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination_;
  ::google::protobuf::uint64 amount_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosTransactionOp_TezosParametersManager final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager) */ {
 public:
  TezosSignTx_TezosTransactionOp_TezosParametersManager();
  virtual ~TezosSignTx_TezosTransactionOp_TezosParametersManager();

  TezosSignTx_TezosTransactionOp_TezosParametersManager(const TezosSignTx_TezosTransactionOp_TezosParametersManager& from);

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager& operator=(const TezosSignTx_TezosTransactionOp_TezosParametersManager& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosTransactionOp_TezosParametersManager(TezosSignTx_TezosTransactionOp_TezosParametersManager&& from) noexcept
    : TezosSignTx_TezosTransactionOp_TezosParametersManager() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager& operator=(TezosSignTx_TezosTransactionOp_TezosParametersManager&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosTransactionOp_TezosParametersManager& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosTransactionOp_TezosParametersManager* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosTransactionOp_TezosParametersManager*>(
               &_TezosSignTx_TezosTransactionOp_TezosParametersManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TezosSignTx_TezosTransactionOp_TezosParametersManager* other);
  friend void swap(TezosSignTx_TezosTransactionOp_TezosParametersManager& a, TezosSignTx_TezosTransactionOp_TezosParametersManager& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosTransactionOp_TezosParametersManager* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager>(nullptr);
  }

  TezosSignTx_TezosTransactionOp_TezosParametersManager* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosTransactionOp_TezosParametersManager& from);
  void MergeFrom(const TezosSignTx_TezosTransactionOp_TezosParametersManager& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosTransactionOp_TezosParametersManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer TezosManagerTransfer;

  // accessors -------------------------------------------------------

  // optional bytes set_delegate = 1;
  bool has_set_delegate() const;
  void clear_set_delegate();
  static const int kSetDelegateFieldNumber = 1;
  const ::std::string& set_delegate() const;
  void set_set_delegate(const ::std::string& value);
  #if LANG_CXX11
  void set_set_delegate(::std::string&& value);
  #endif
  void set_set_delegate(const char* value);
  void set_set_delegate(const void* value, size_t size);
  ::std::string* mutable_set_delegate();
  ::std::string* release_set_delegate();
  void set_allocated_set_delegate(::std::string* set_delegate);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer transfer = 3;
  bool has_transfer() const;
  void clear_transfer();
  static const int kTransferFieldNumber = 3;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& transfer() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* release_transfer();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* mutable_transfer();
  void set_allocated_transfer(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* transfer);

  // optional bool cancel_delegate = 2;
  bool has_cancel_delegate() const;
  void clear_cancel_delegate();
  static const int kCancelDelegateFieldNumber = 2;
  bool cancel_delegate() const;
  void set_cancel_delegate(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr set_delegate_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* transfer_;
  bool cancel_delegate_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosTransactionOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp) */ {
 public:
  TezosSignTx_TezosTransactionOp();
  virtual ~TezosSignTx_TezosTransactionOp();

  TezosSignTx_TezosTransactionOp(const TezosSignTx_TezosTransactionOp& from);

  inline TezosSignTx_TezosTransactionOp& operator=(const TezosSignTx_TezosTransactionOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosTransactionOp(TezosSignTx_TezosTransactionOp&& from) noexcept
    : TezosSignTx_TezosTransactionOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosTransactionOp& operator=(TezosSignTx_TezosTransactionOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosTransactionOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosTransactionOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosTransactionOp*>(
               &_TezosSignTx_TezosTransactionOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TezosSignTx_TezosTransactionOp* other);
  friend void swap(TezosSignTx_TezosTransactionOp& a, TezosSignTx_TezosTransactionOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosTransactionOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp>(nullptr);
  }

  TezosSignTx_TezosTransactionOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosTransactionOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosTransactionOp& from);
  void MergeFrom(const TezosSignTx_TezosTransactionOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosTransactionOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TezosSignTx_TezosTransactionOp_TezosParametersManager TezosParametersManager;

  // accessors -------------------------------------------------------

  // optional bytes parameters = 8;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 8;
  const ::std::string& parameters() const;
  void set_parameters(const ::std::string& value);
  #if LANG_CXX11
  void set_parameters(::std::string&& value);
  #endif
  void set_parameters(const char* value);
  void set_parameters(const void* value, size_t size);
  ::std::string* mutable_parameters();
  ::std::string* release_parameters();
  void set_allocated_parameters(::std::string* parameters);

  // optional bytes source = 9;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 9;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 7;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 7;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID& destination() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* release_destination();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* mutable_destination();
  void set_allocated_destination(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager parameters_manager = 10;
  bool has_parameters_manager() const;
  void clear_parameters_manager();
  static const int kParametersManagerFieldNumber = 10;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager& parameters_manager() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* release_parameters_manager();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* mutable_parameters_manager();
  void set_allocated_parameters_manager(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* parameters_manager);

  // optional uint64 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 counter = 3;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 3;
  ::google::protobuf::uint64 counter() const;
  void set_counter(::google::protobuf::uint64 value);

  // optional uint64 gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // optional uint64 storage_limit = 5;
  bool has_storage_limit() const;
  void clear_storage_limit();
  static const int kStorageLimitFieldNumber = 5;
  ::google::protobuf::uint64 storage_limit() const;
  void set_storage_limit(::google::protobuf::uint64 value);

  // optional uint64 amount = 6;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 6;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr parameters_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* parameters_manager_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 counter_;
  ::google::protobuf::uint64 gas_limit_;
  ::google::protobuf::uint64 storage_limit_;
  ::google::protobuf::uint64 amount_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosOriginationOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp) */ {
 public:
  TezosSignTx_TezosOriginationOp();
  virtual ~TezosSignTx_TezosOriginationOp();

  TezosSignTx_TezosOriginationOp(const TezosSignTx_TezosOriginationOp& from);

  inline TezosSignTx_TezosOriginationOp& operator=(const TezosSignTx_TezosOriginationOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosOriginationOp(TezosSignTx_TezosOriginationOp&& from) noexcept
    : TezosSignTx_TezosOriginationOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosOriginationOp& operator=(TezosSignTx_TezosOriginationOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosOriginationOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosOriginationOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosOriginationOp*>(
               &_TezosSignTx_TezosOriginationOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TezosSignTx_TezosOriginationOp* other);
  friend void swap(TezosSignTx_TezosOriginationOp& a, TezosSignTx_TezosOriginationOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosOriginationOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosOriginationOp>(nullptr);
  }

  TezosSignTx_TezosOriginationOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosOriginationOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosOriginationOp& from);
  void MergeFrom(const TezosSignTx_TezosOriginationOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosOriginationOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes manager_pubkey = 6;
  bool has_manager_pubkey() const;
  void clear_manager_pubkey();
  static const int kManagerPubkeyFieldNumber = 6;
  const ::std::string& manager_pubkey() const;
  void set_manager_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_manager_pubkey(::std::string&& value);
  #endif
  void set_manager_pubkey(const char* value);
  void set_manager_pubkey(const void* value, size_t size);
  ::std::string* mutable_manager_pubkey();
  ::std::string* release_manager_pubkey();
  void set_allocated_manager_pubkey(::std::string* manager_pubkey);

  // optional bytes delegate = 10;
  bool has_delegate() const;
  void clear_delegate();
  static const int kDelegateFieldNumber = 10;
  const ::std::string& delegate() const;
  void set_delegate(const ::std::string& value);
  #if LANG_CXX11
  void set_delegate(::std::string&& value);
  #endif
  void set_delegate(const char* value);
  void set_delegate(const void* value, size_t size);
  ::std::string* mutable_delegate();
  ::std::string* release_delegate();
  void set_allocated_delegate(::std::string* delegate);

  // optional bytes script = 11;
  bool has_script() const;
  void clear_script();
  static const int kScriptFieldNumber = 11;
  const ::std::string& script() const;
  void set_script(const ::std::string& value);
  #if LANG_CXX11
  void set_script(::std::string&& value);
  #endif
  void set_script(const char* value);
  void set_script(const void* value, size_t size);
  ::std::string* mutable_script();
  ::std::string* release_script();
  void set_allocated_script(::std::string* script);

  // optional bytes source = 12;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 12;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional uint64 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 counter = 3;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 3;
  ::google::protobuf::uint64 counter() const;
  void set_counter(::google::protobuf::uint64 value);

  // optional uint64 gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // optional uint64 storage_limit = 5;
  bool has_storage_limit() const;
  void clear_storage_limit();
  static const int kStorageLimitFieldNumber = 5;
  ::google::protobuf::uint64 storage_limit() const;
  void set_storage_limit(::google::protobuf::uint64 value);

  // optional uint64 balance = 7;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 7;
  ::google::protobuf::uint64 balance() const;
  void set_balance(::google::protobuf::uint64 value);

  // optional bool spendable = 8;
  bool has_spendable() const;
  void clear_spendable();
  static const int kSpendableFieldNumber = 8;
  bool spendable() const;
  void set_spendable(bool value);

  // optional bool delegatable = 9;
  bool has_delegatable() const;
  void clear_delegatable();
  static const int kDelegatableFieldNumber = 9;
  bool delegatable() const;
  void set_delegatable(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr manager_pubkey_;
  ::google::protobuf::internal::ArenaStringPtr delegate_;
  ::google::protobuf::internal::ArenaStringPtr script_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 counter_;
  ::google::protobuf::uint64 gas_limit_;
  ::google::protobuf::uint64 storage_limit_;
  ::google::protobuf::uint64 balance_;
  bool spendable_;
  bool delegatable_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosDelegationOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp) */ {
 public:
  TezosSignTx_TezosDelegationOp();
  virtual ~TezosSignTx_TezosDelegationOp();

  TezosSignTx_TezosDelegationOp(const TezosSignTx_TezosDelegationOp& from);

  inline TezosSignTx_TezosDelegationOp& operator=(const TezosSignTx_TezosDelegationOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosDelegationOp(TezosSignTx_TezosDelegationOp&& from) noexcept
    : TezosSignTx_TezosDelegationOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosDelegationOp& operator=(TezosSignTx_TezosDelegationOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosDelegationOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosDelegationOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosDelegationOp*>(
               &_TezosSignTx_TezosDelegationOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(TezosSignTx_TezosDelegationOp* other);
  friend void swap(TezosSignTx_TezosDelegationOp& a, TezosSignTx_TezosDelegationOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosDelegationOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosDelegationOp>(nullptr);
  }

  TezosSignTx_TezosDelegationOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosDelegationOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosDelegationOp& from);
  void MergeFrom(const TezosSignTx_TezosDelegationOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosDelegationOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes delegate = 6;
  bool has_delegate() const;
  void clear_delegate();
  static const int kDelegateFieldNumber = 6;
  const ::std::string& delegate() const;
  void set_delegate(const ::std::string& value);
  #if LANG_CXX11
  void set_delegate(::std::string&& value);
  #endif
  void set_delegate(const char* value);
  void set_delegate(const void* value, size_t size);
  ::std::string* mutable_delegate();
  ::std::string* release_delegate();
  void set_allocated_delegate(::std::string* delegate);

  // optional bytes source = 7;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 7;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional uint64 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 counter = 3;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 3;
  ::google::protobuf::uint64 counter() const;
  void set_counter(::google::protobuf::uint64 value);

  // optional uint64 gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // optional uint64 storage_limit = 5;
  bool has_storage_limit() const;
  void clear_storage_limit();
  static const int kStorageLimitFieldNumber = 5;
  ::google::protobuf::uint64 storage_limit() const;
  void set_storage_limit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr delegate_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 counter_;
  ::google::protobuf::uint64 gas_limit_;
  ::google::protobuf::uint64 storage_limit_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosProposalOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp) */ {
 public:
  TezosSignTx_TezosProposalOp();
  virtual ~TezosSignTx_TezosProposalOp();

  TezosSignTx_TezosProposalOp(const TezosSignTx_TezosProposalOp& from);

  inline TezosSignTx_TezosProposalOp& operator=(const TezosSignTx_TezosProposalOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosProposalOp(TezosSignTx_TezosProposalOp&& from) noexcept
    : TezosSignTx_TezosProposalOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosProposalOp& operator=(TezosSignTx_TezosProposalOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosProposalOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosProposalOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosProposalOp*>(
               &_TezosSignTx_TezosProposalOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(TezosSignTx_TezosProposalOp* other);
  friend void swap(TezosSignTx_TezosProposalOp& a, TezosSignTx_TezosProposalOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosProposalOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosProposalOp>(nullptr);
  }

  TezosSignTx_TezosProposalOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosProposalOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosProposalOp& from);
  void MergeFrom(const TezosSignTx_TezosProposalOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosProposalOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes proposals = 4;
  int proposals_size() const;
  void clear_proposals();
  static const int kProposalsFieldNumber = 4;
  const ::std::string& proposals(int index) const;
  ::std::string* mutable_proposals(int index);
  void set_proposals(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_proposals(int index, ::std::string&& value);
  #endif
  void set_proposals(int index, const char* value);
  void set_proposals(int index, const void* value, size_t size);
  ::std::string* add_proposals();
  void add_proposals(const ::std::string& value);
  #if LANG_CXX11
  void add_proposals(::std::string&& value);
  #endif
  void add_proposals(const char* value);
  void add_proposals(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& proposals() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_proposals();

  // optional bytes source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional uint64 period = 2;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 2;
  ::google::protobuf::uint64 period() const;
  void set_period(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> proposals_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::uint64 period_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx_TezosBallotOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp) */ {
 public:
  TezosSignTx_TezosBallotOp();
  virtual ~TezosSignTx_TezosBallotOp();

  TezosSignTx_TezosBallotOp(const TezosSignTx_TezosBallotOp& from);

  inline TezosSignTx_TezosBallotOp& operator=(const TezosSignTx_TezosBallotOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx_TezosBallotOp(TezosSignTx_TezosBallotOp&& from) noexcept
    : TezosSignTx_TezosBallotOp() {
    *this = ::std::move(from);
  }

  inline TezosSignTx_TezosBallotOp& operator=(TezosSignTx_TezosBallotOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx_TezosBallotOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx_TezosBallotOp* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx_TezosBallotOp*>(
               &_TezosSignTx_TezosBallotOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TezosSignTx_TezosBallotOp* other);
  friend void swap(TezosSignTx_TezosBallotOp& a, TezosSignTx_TezosBallotOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx_TezosBallotOp* New() const final {
    return CreateMaybeMessage<TezosSignTx_TezosBallotOp>(nullptr);
  }

  TezosSignTx_TezosBallotOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx_TezosBallotOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx_TezosBallotOp& from);
  void MergeFrom(const TezosSignTx_TezosBallotOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx_TezosBallotOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TezosSignTx_TezosBallotOp_TezosBallotType TezosBallotType;
  static const TezosBallotType Yay =
    TezosSignTx_TezosBallotOp_TezosBallotType_Yay;
  static const TezosBallotType Nay =
    TezosSignTx_TezosBallotOp_TezosBallotType_Nay;
  static const TezosBallotType Pass =
    TezosSignTx_TezosBallotOp_TezosBallotType_Pass;
  static inline bool TezosBallotType_IsValid(int value) {
    return TezosSignTx_TezosBallotOp_TezosBallotType_IsValid(value);
  }
  static const TezosBallotType TezosBallotType_MIN =
    TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_MIN;
  static const TezosBallotType TezosBallotType_MAX =
    TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_MAX;
  static const int TezosBallotType_ARRAYSIZE =
    TezosSignTx_TezosBallotOp_TezosBallotType_TezosBallotType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TezosBallotType_descriptor() {
    return TezosSignTx_TezosBallotOp_TezosBallotType_descriptor();
  }
  static inline const ::std::string& TezosBallotType_Name(TezosBallotType value) {
    return TezosSignTx_TezosBallotOp_TezosBallotType_Name(value);
  }
  static inline bool TezosBallotType_Parse(const ::std::string& name,
      TezosBallotType* value) {
    return TezosSignTx_TezosBallotOp_TezosBallotType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional bytes proposal = 3;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 3;
  const ::std::string& proposal() const;
  void set_proposal(const ::std::string& value);
  #if LANG_CXX11
  void set_proposal(::std::string&& value);
  #endif
  void set_proposal(const char* value);
  void set_proposal(const void* value, size_t size);
  ::std::string* mutable_proposal();
  ::std::string* release_proposal();
  void set_allocated_proposal(::std::string* proposal);

  // optional uint64 period = 2;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 2;
  ::google::protobuf::uint64 period() const;
  void set_period(::google::protobuf::uint64 value);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.TezosBallotType ballot = 4;
  bool has_ballot() const;
  void clear_ballot();
  static const int kBallotFieldNumber = 4;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType ballot() const;
  void set_ballot(::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr proposal_;
  ::google::protobuf::uint64 period_;
  int ballot_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignTx) */ {
 public:
  TezosSignTx();
  virtual ~TezosSignTx();

  TezosSignTx(const TezosSignTx& from);

  inline TezosSignTx& operator=(const TezosSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignTx(TezosSignTx&& from) noexcept
    : TezosSignTx() {
    *this = ::std::move(from);
  }

  inline TezosSignTx& operator=(TezosSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignTx* internal_default_instance() {
    return reinterpret_cast<const TezosSignTx*>(
               &_TezosSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TezosSignTx* other);
  friend void swap(TezosSignTx& a, TezosSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignTx* New() const final {
    return CreateMaybeMessage<TezosSignTx>(nullptr);
  }

  TezosSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignTx& from);
  void MergeFrom(const TezosSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TezosSignTx_TezosContractID TezosContractID;
  typedef TezosSignTx_TezosRevealOp TezosRevealOp;
  typedef TezosSignTx_TezosTransactionOp TezosTransactionOp;
  typedef TezosSignTx_TezosOriginationOp TezosOriginationOp;
  typedef TezosSignTx_TezosDelegationOp TezosDelegationOp;
  typedef TezosSignTx_TezosProposalOp TezosProposalOp;
  typedef TezosSignTx_TezosBallotOp TezosBallotOp;

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes branch = 2;
  bool has_branch() const;
  void clear_branch();
  static const int kBranchFieldNumber = 2;
  const ::std::string& branch() const;
  void set_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_branch(::std::string&& value);
  #endif
  void set_branch(const char* value);
  void set_branch(const void* value, size_t size);
  ::std::string* mutable_branch();
  ::std::string* release_branch();
  void set_allocated_branch(::std::string* branch);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp reveal = 3;
  bool has_reveal() const;
  void clear_reveal();
  static const int kRevealFieldNumber = 3;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp& reveal() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* release_reveal();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* mutable_reveal();
  void set_allocated_reveal(::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* reveal);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp transaction = 4;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 4;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp& transaction() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* release_transaction();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* mutable_transaction();
  void set_allocated_transaction(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* transaction);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp origination = 5;
  bool has_origination() const;
  void clear_origination();
  static const int kOriginationFieldNumber = 5;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp& origination() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* release_origination();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* mutable_origination();
  void set_allocated_origination(::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* origination);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp delegation = 6;
  bool has_delegation() const;
  void clear_delegation();
  static const int kDelegationFieldNumber = 6;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp& delegation() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* release_delegation();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* mutable_delegation();
  void set_allocated_delegation(::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* delegation);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp proposal = 7;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 7;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp& proposal() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* release_proposal();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* mutable_proposal();
  void set_allocated_proposal(::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* proposal);

  // optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp ballot = 8;
  bool has_ballot() const;
  void clear_ballot();
  static const int kBallotFieldNumber = 8;
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp& ballot() const;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* release_ballot();
  ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* mutable_ballot();
  void set_allocated_ballot(::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* ballot);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr branch_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* reveal_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* transaction_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* origination_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* delegation_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* proposal_;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* ballot_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// -------------------------------------------------------------------

class TezosSignedTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.tezos.TezosSignedTx) */ {
 public:
  TezosSignedTx();
  virtual ~TezosSignedTx();

  TezosSignedTx(const TezosSignedTx& from);

  inline TezosSignedTx& operator=(const TezosSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TezosSignedTx(TezosSignedTx&& from) noexcept
    : TezosSignedTx() {
    *this = ::std::move(from);
  }

  inline TezosSignedTx& operator=(TezosSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TezosSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TezosSignedTx* internal_default_instance() {
    return reinterpret_cast<const TezosSignedTx*>(
               &_TezosSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TezosSignedTx* other);
  friend void swap(TezosSignedTx& a, TezosSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TezosSignedTx* New() const final {
    return CreateMaybeMessage<TezosSignedTx>(nullptr);
  }

  TezosSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TezosSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TezosSignedTx& from);
  void MergeFrom(const TezosSignedTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TezosSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes sig_op_contents = 2;
  bool has_sig_op_contents() const;
  void clear_sig_op_contents();
  static const int kSigOpContentsFieldNumber = 2;
  const ::std::string& sig_op_contents() const;
  void set_sig_op_contents(const ::std::string& value);
  #if LANG_CXX11
  void set_sig_op_contents(::std::string&& value);
  #endif
  void set_sig_op_contents(const char* value);
  void set_sig_op_contents(const void* value, size_t size);
  ::std::string* mutable_sig_op_contents();
  ::std::string* release_sig_op_contents();
  void set_allocated_sig_op_contents(::std::string* sig_op_contents);

  // optional string operation_hash = 3;
  bool has_operation_hash() const;
  void clear_operation_hash();
  static const int kOperationHashFieldNumber = 3;
  const ::std::string& operation_hash() const;
  void set_operation_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_operation_hash(::std::string&& value);
  #endif
  void set_operation_hash(const char* value);
  void set_operation_hash(const char* value, size_t size);
  ::std::string* mutable_operation_hash();
  ::std::string* release_operation_hash();
  void set_allocated_operation_hash(::std::string* operation_hash);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.tezos.TezosSignedTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr sig_op_contents_;
  ::google::protobuf::internal::ArenaStringPtr operation_hash_;
  friend struct ::TableStruct_messages_2dtezos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TezosGetAddress

// repeated uint32 address_n = 1;
inline int TezosGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void TezosGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TezosGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosGetAddress.address_n)
  return address_n_.Get(index);
}
inline void TezosGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosGetAddress.address_n)
}
inline void TezosGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.tezos.TezosGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TezosGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.tezos.TezosGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TezosGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.tezos.TezosGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool TezosGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TezosGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosGetAddress.show_display)
  return show_display_;
}
inline void TezosGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosGetAddress.show_display)
}

// -------------------------------------------------------------------

// TezosAddress

// optional string address = 1;
inline bool TezosAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosAddress.address)
  return address_.GetNoArena();
}
inline void TezosAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosAddress.address)
}
#if LANG_CXX11
inline void TezosAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosAddress.address)
}
#endif
inline void TezosAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosAddress.address)
}
inline void TezosAddress::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosAddress.address)
}
inline ::std::string* TezosAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosAddress.address)
}

// -------------------------------------------------------------------

// TezosGetPublicKey

// repeated uint32 address_n = 1;
inline int TezosGetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void TezosGetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TezosGetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosGetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void TezosGetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosGetPublicKey.address_n)
}
inline void TezosGetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.tezos.TezosGetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TezosGetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.tezos.TezosGetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TezosGetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.tezos.TezosGetPublicKey.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool TezosGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TezosGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosGetPublicKey.show_display)
  return show_display_;
}
inline void TezosGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// TezosPublicKey

// optional string public_key = 1;
inline bool TezosPublicKey::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosPublicKey::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosPublicKey::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosPublicKey.public_key)
  return public_key_.GetNoArena();
}
inline void TezosPublicKey::set_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosPublicKey.public_key)
}
#if LANG_CXX11
inline void TezosPublicKey::set_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosPublicKey.public_key)
}
#endif
inline void TezosPublicKey::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosPublicKey.public_key)
}
inline void TezosPublicKey::set_public_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosPublicKey.public_key)
}
inline ::std::string* TezosPublicKey::mutable_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosPublicKey.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosPublicKey::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosPublicKey.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosPublicKey::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosPublicKey.public_key)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosContractID

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID.TezosContractType tag = 1;
inline bool TezosSignTx_TezosContractID::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosContractID::clear_tag() {
  tag_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType TezosSignTx_TezosContractID::tag() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.tag)
  return static_cast< ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType >(tag_);
}
inline void TezosSignTx_TezosContractID::set_tag(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType value) {
  assert(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  tag_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.tag)
}

// optional bytes hash = 2;
inline bool TezosSignTx_TezosContractID::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosContractID::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosContractID::hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
  return hash_.GetNoArena();
}
inline void TezosSignTx_TezosContractID::set_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
}
#if LANG_CXX11
inline void TezosSignTx_TezosContractID::set_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
}
#endif
inline void TezosSignTx_TezosContractID::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
}
inline void TezosSignTx_TezosContractID::set_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
}
inline ::std::string* TezosSignTx_TezosContractID::mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosContractID::release_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosContractID::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosContractID.hash)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosRevealOp

// optional bytes source = 7;
inline bool TezosSignTx_TezosRevealOp::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignTx_TezosRevealOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosRevealOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosRevealOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
}
#endif
inline void TezosSignTx_TezosRevealOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
}
inline void TezosSignTx_TezosRevealOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
}
inline ::std::string* TezosSignTx_TezosRevealOp::mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosRevealOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosRevealOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.source)
}

// optional uint64 fee = 2;
inline bool TezosSignTx_TezosRevealOp::has_fee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosRevealOp::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.fee)
  return fee_;
}
inline void TezosSignTx_TezosRevealOp::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.fee)
}

// optional uint64 counter = 3;
inline bool TezosSignTx_TezosRevealOp::has_counter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_counter() {
  counter_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosRevealOp::counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.counter)
  return counter_;
}
inline void TezosSignTx_TezosRevealOp::set_counter(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.counter)
}

// optional uint64 gas_limit = 4;
inline bool TezosSignTx_TezosRevealOp::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_gas_limit() {
  gas_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosRevealOp::gas_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.gas_limit)
  return gas_limit_;
}
inline void TezosSignTx_TezosRevealOp::set_gas_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.gas_limit)
}

// optional uint64 storage_limit = 5;
inline bool TezosSignTx_TezosRevealOp::has_storage_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_storage_limit() {
  storage_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosRevealOp::storage_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.storage_limit)
  return storage_limit_;
}
inline void TezosSignTx_TezosRevealOp::set_storage_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  storage_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.storage_limit)
}

// optional bytes public_key = 6;
inline bool TezosSignTx_TezosRevealOp::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosRevealOp::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosRevealOp::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
  return public_key_.GetNoArena();
}
inline void TezosSignTx_TezosRevealOp::set_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
}
#if LANG_CXX11
inline void TezosSignTx_TezosRevealOp::set_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
}
#endif
inline void TezosSignTx_TezosRevealOp::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
}
inline void TezosSignTx_TezosRevealOp::set_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
}
inline ::std::string* TezosSignTx_TezosRevealOp::mutable_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosRevealOp::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosRevealOp::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp.public_key)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 1;
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::clear_destination() {
  if (destination_ != nullptr) destination_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID& TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::destination() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* p = destination_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.destination)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosContractID_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::release_destination() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.destination)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::mutable_destination() {
  _has_bits_[0] |= 0x00000001u;
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosContractID>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.destination)
  return destination_;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::set_allocated_destination(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete destination_;
  }
  if (destination) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.destination)
}

// optional uint64 amount = 2;
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.amount)
  return amount_;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer.amount)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosTransactionOp_TezosParametersManager

// optional bytes set_delegate = 1;
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager::has_set_delegate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::clear_set_delegate() {
  set_delegate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosTransactionOp_TezosParametersManager::set_delegate() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
  return set_delegate_.GetNoArena();
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_set_delegate(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  set_delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
}
#if LANG_CXX11
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_set_delegate(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  set_delegate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
}
#endif
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_set_delegate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  set_delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_set_delegate(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  set_delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
}
inline ::std::string* TezosSignTx_TezosTransactionOp_TezosParametersManager::mutable_set_delegate() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
  return set_delegate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosTransactionOp_TezosParametersManager::release_set_delegate() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
  if (!has_set_delegate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return set_delegate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_allocated_set_delegate(::std::string* set_delegate) {
  if (set_delegate != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  set_delegate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), set_delegate);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.set_delegate)
}

// optional bool cancel_delegate = 2;
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager::has_cancel_delegate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::clear_cancel_delegate() {
  cancel_delegate_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager::cancel_delegate() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.cancel_delegate)
  return cancel_delegate_;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_cancel_delegate(bool value) {
  _has_bits_[0] |= 0x00000004u;
  cancel_delegate_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.cancel_delegate)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer transfer = 3;
inline bool TezosSignTx_TezosTransactionOp_TezosParametersManager::has_transfer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::clear_transfer() {
  if (transfer_ != nullptr) transfer_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer& TezosSignTx_TezosTransactionOp_TezosParametersManager::transfer() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* p = transfer_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.transfer)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* TezosSignTx_TezosTransactionOp_TezosParametersManager::release_transfer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.transfer)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* temp = transfer_;
  transfer_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* TezosSignTx_TezosTransactionOp_TezosParametersManager::mutable_transfer() {
  _has_bits_[0] |= 0x00000002u;
  if (transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>(GetArenaNoVirtual());
    transfer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.transfer)
  return transfer_;
}
inline void TezosSignTx_TezosTransactionOp_TezosParametersManager::set_allocated_transfer(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer* transfer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transfer_;
  }
  if (transfer) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transfer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transfer_ = transfer;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.transfer)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosTransactionOp

// optional bytes source = 9;
inline bool TezosSignTx_TezosTransactionOp::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignTx_TezosTransactionOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosTransactionOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosTransactionOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
}
#endif
inline void TezosSignTx_TezosTransactionOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
}
inline void TezosSignTx_TezosTransactionOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
}
inline ::std::string* TezosSignTx_TezosTransactionOp::mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosTransactionOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosTransactionOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.source)
}

// optional uint64 fee = 2;
inline bool TezosSignTx_TezosTransactionOp::has_fee() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.fee)
  return fee_;
}
inline void TezosSignTx_TezosTransactionOp::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.fee)
}

// optional uint64 counter = 3;
inline bool TezosSignTx_TezosTransactionOp::has_counter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_counter() {
  counter_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp::counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.counter)
  return counter_;
}
inline void TezosSignTx_TezosTransactionOp::set_counter(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.counter)
}

// optional uint64 gas_limit = 4;
inline bool TezosSignTx_TezosTransactionOp::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_gas_limit() {
  gas_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp::gas_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.gas_limit)
  return gas_limit_;
}
inline void TezosSignTx_TezosTransactionOp::set_gas_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.gas_limit)
}

// optional uint64 storage_limit = 5;
inline bool TezosSignTx_TezosTransactionOp::has_storage_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_storage_limit() {
  storage_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp::storage_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.storage_limit)
  return storage_limit_;
}
inline void TezosSignTx_TezosTransactionOp::set_storage_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  storage_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.storage_limit)
}

// optional uint64 amount = 6;
inline bool TezosSignTx_TezosTransactionOp::has_amount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosTransactionOp::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.amount)
  return amount_;
}
inline void TezosSignTx_TezosTransactionOp::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.amount)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 7;
inline bool TezosSignTx_TezosTransactionOp::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_destination() {
  if (destination_ != nullptr) destination_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID& TezosSignTx_TezosTransactionOp::destination() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* p = destination_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.destination)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosContractID_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* TezosSignTx_TezosTransactionOp::release_destination() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.destination)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* TezosSignTx_TezosTransactionOp::mutable_destination() {
  _has_bits_[0] |= 0x00000004u;
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosContractID>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.destination)
  return destination_;
}
inline void TezosSignTx_TezosTransactionOp::set_allocated_destination(::hw::trezor::messages::tezos::TezosSignTx_TezosContractID* destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete destination_;
  }
  if (destination) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.destination)
}

// optional bytes parameters = 8;
inline bool TezosSignTx_TezosTransactionOp::has_parameters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_parameters() {
  parameters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosTransactionOp::parameters() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
  return parameters_.GetNoArena();
}
inline void TezosSignTx_TezosTransactionOp::set_parameters(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
}
#if LANG_CXX11
inline void TezosSignTx_TezosTransactionOp::set_parameters(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  parameters_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
}
#endif
inline void TezosSignTx_TezosTransactionOp::set_parameters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
}
inline void TezosSignTx_TezosTransactionOp::set_parameters(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
}
inline ::std::string* TezosSignTx_TezosTransactionOp::mutable_parameters() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
  return parameters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosTransactionOp::release_parameters() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
  if (!has_parameters()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return parameters_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosTransactionOp::set_allocated_parameters(::std::string* parameters) {
  if (parameters != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parameters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parameters);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager parameters_manager = 10;
inline bool TezosSignTx_TezosTransactionOp::has_parameters_manager() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx_TezosTransactionOp::clear_parameters_manager() {
  if (parameters_manager_ != nullptr) parameters_manager_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager& TezosSignTx_TezosTransactionOp::parameters_manager() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* p = parameters_manager_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters_manager)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosTransactionOp_TezosParametersManager_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* TezosSignTx_TezosTransactionOp::release_parameters_manager() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters_manager)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* temp = parameters_manager_;
  parameters_manager_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* TezosSignTx_TezosTransactionOp::mutable_parameters_manager() {
  _has_bits_[0] |= 0x00000008u;
  if (parameters_manager_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager>(GetArenaNoVirtual());
    parameters_manager_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters_manager)
  return parameters_manager_;
}
inline void TezosSignTx_TezosTransactionOp::set_allocated_parameters_manager(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp_TezosParametersManager* parameters_manager) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete parameters_manager_;
  }
  if (parameters_manager) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parameters_manager = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameters_manager, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  parameters_manager_ = parameters_manager;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.parameters_manager)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosOriginationOp

// optional bytes source = 12;
inline bool TezosSignTx_TezosOriginationOp::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& TezosSignTx_TezosOriginationOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosOriginationOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosOriginationOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
}
#endif
inline void TezosSignTx_TezosOriginationOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
}
inline void TezosSignTx_TezosOriginationOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
}
inline ::std::string* TezosSignTx_TezosOriginationOp::mutable_source() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosOriginationOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosOriginationOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.source)
}

// optional uint64 fee = 2;
inline bool TezosSignTx_TezosOriginationOp::has_fee() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosOriginationOp::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.fee)
  return fee_;
}
inline void TezosSignTx_TezosOriginationOp::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.fee)
}

// optional uint64 counter = 3;
inline bool TezosSignTx_TezosOriginationOp::has_counter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_counter() {
  counter_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosOriginationOp::counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.counter)
  return counter_;
}
inline void TezosSignTx_TezosOriginationOp::set_counter(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.counter)
}

// optional uint64 gas_limit = 4;
inline bool TezosSignTx_TezosOriginationOp::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_gas_limit() {
  gas_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosOriginationOp::gas_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.gas_limit)
  return gas_limit_;
}
inline void TezosSignTx_TezosOriginationOp::set_gas_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.gas_limit)
}

// optional uint64 storage_limit = 5;
inline bool TezosSignTx_TezosOriginationOp::has_storage_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_storage_limit() {
  storage_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosOriginationOp::storage_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.storage_limit)
  return storage_limit_;
}
inline void TezosSignTx_TezosOriginationOp::set_storage_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  storage_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.storage_limit)
}

// optional bytes manager_pubkey = 6;
inline bool TezosSignTx_TezosOriginationOp::has_manager_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_manager_pubkey() {
  manager_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosOriginationOp::manager_pubkey() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
  return manager_pubkey_.GetNoArena();
}
inline void TezosSignTx_TezosOriginationOp::set_manager_pubkey(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manager_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
}
#if LANG_CXX11
inline void TezosSignTx_TezosOriginationOp::set_manager_pubkey(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manager_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
}
#endif
inline void TezosSignTx_TezosOriginationOp::set_manager_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manager_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
}
inline void TezosSignTx_TezosOriginationOp::set_manager_pubkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manager_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
}
inline ::std::string* TezosSignTx_TezosOriginationOp::mutable_manager_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
  return manager_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosOriginationOp::release_manager_pubkey() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
  if (!has_manager_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manager_pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosOriginationOp::set_allocated_manager_pubkey(::std::string* manager_pubkey) {
  if (manager_pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manager_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manager_pubkey);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.manager_pubkey)
}

// optional uint64 balance = 7;
inline bool TezosSignTx_TezosOriginationOp::has_balance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_balance() {
  balance_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosOriginationOp::balance() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.balance)
  return balance_;
}
inline void TezosSignTx_TezosOriginationOp::set_balance(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  balance_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.balance)
}

// optional bool spendable = 8;
inline bool TezosSignTx_TezosOriginationOp::has_spendable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_spendable() {
  spendable_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool TezosSignTx_TezosOriginationOp::spendable() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.spendable)
  return spendable_;
}
inline void TezosSignTx_TezosOriginationOp::set_spendable(bool value) {
  _has_bits_[0] |= 0x00000200u;
  spendable_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.spendable)
}

// optional bool delegatable = 9;
inline bool TezosSignTx_TezosOriginationOp::has_delegatable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_delegatable() {
  delegatable_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool TezosSignTx_TezosOriginationOp::delegatable() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegatable)
  return delegatable_;
}
inline void TezosSignTx_TezosOriginationOp::set_delegatable(bool value) {
  _has_bits_[0] |= 0x00000400u;
  delegatable_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegatable)
}

// optional bytes delegate = 10;
inline bool TezosSignTx_TezosOriginationOp::has_delegate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_delegate() {
  delegate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignTx_TezosOriginationOp::delegate() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
  return delegate_.GetNoArena();
}
inline void TezosSignTx_TezosOriginationOp::set_delegate(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
}
#if LANG_CXX11
inline void TezosSignTx_TezosOriginationOp::set_delegate(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  delegate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
}
#endif
inline void TezosSignTx_TezosOriginationOp::set_delegate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
}
inline void TezosSignTx_TezosOriginationOp::set_delegate(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
}
inline ::std::string* TezosSignTx_TezosOriginationOp::mutable_delegate() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
  return delegate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosOriginationOp::release_delegate() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
  if (!has_delegate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return delegate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosOriginationOp::set_allocated_delegate(::std::string* delegate) {
  if (delegate != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  delegate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delegate);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.delegate)
}

// optional bytes script = 11;
inline bool TezosSignTx_TezosOriginationOp::has_script() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosOriginationOp::clear_script() {
  script_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TezosSignTx_TezosOriginationOp::script() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
  return script_.GetNoArena();
}
inline void TezosSignTx_TezosOriginationOp::set_script(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
}
#if LANG_CXX11
inline void TezosSignTx_TezosOriginationOp::set_script(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  script_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
}
#endif
inline void TezosSignTx_TezosOriginationOp::set_script(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
}
inline void TezosSignTx_TezosOriginationOp::set_script(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
}
inline ::std::string* TezosSignTx_TezosOriginationOp::mutable_script() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
  return script_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosOriginationOp::release_script() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
  if (!has_script()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return script_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosOriginationOp::set_allocated_script(::std::string* script) {
  if (script != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  script_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp.script)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosDelegationOp

// optional bytes source = 7;
inline bool TezosSignTx_TezosDelegationOp::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignTx_TezosDelegationOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosDelegationOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosDelegationOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
}
#endif
inline void TezosSignTx_TezosDelegationOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
}
inline void TezosSignTx_TezosDelegationOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
}
inline ::std::string* TezosSignTx_TezosDelegationOp::mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosDelegationOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosDelegationOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.source)
}

// optional uint64 fee = 2;
inline bool TezosSignTx_TezosDelegationOp::has_fee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosDelegationOp::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.fee)
  return fee_;
}
inline void TezosSignTx_TezosDelegationOp::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.fee)
}

// optional uint64 counter = 3;
inline bool TezosSignTx_TezosDelegationOp::has_counter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_counter() {
  counter_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosDelegationOp::counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.counter)
  return counter_;
}
inline void TezosSignTx_TezosDelegationOp::set_counter(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.counter)
}

// optional uint64 gas_limit = 4;
inline bool TezosSignTx_TezosDelegationOp::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_gas_limit() {
  gas_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosDelegationOp::gas_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.gas_limit)
  return gas_limit_;
}
inline void TezosSignTx_TezosDelegationOp::set_gas_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.gas_limit)
}

// optional uint64 storage_limit = 5;
inline bool TezosSignTx_TezosDelegationOp::has_storage_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_storage_limit() {
  storage_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosDelegationOp::storage_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.storage_limit)
  return storage_limit_;
}
inline void TezosSignTx_TezosDelegationOp::set_storage_limit(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  storage_limit_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.storage_limit)
}

// optional bytes delegate = 6;
inline bool TezosSignTx_TezosDelegationOp::has_delegate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosDelegationOp::clear_delegate() {
  delegate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosDelegationOp::delegate() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
  return delegate_.GetNoArena();
}
inline void TezosSignTx_TezosDelegationOp::set_delegate(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
}
#if LANG_CXX11
inline void TezosSignTx_TezosDelegationOp::set_delegate(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  delegate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
}
#endif
inline void TezosSignTx_TezosDelegationOp::set_delegate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
}
inline void TezosSignTx_TezosDelegationOp::set_delegate(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  delegate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
}
inline ::std::string* TezosSignTx_TezosDelegationOp::mutable_delegate() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
  return delegate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosDelegationOp::release_delegate() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
  if (!has_delegate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return delegate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosDelegationOp::set_allocated_delegate(::std::string* delegate) {
  if (delegate != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  delegate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delegate);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp.delegate)
}

// -------------------------------------------------------------------

// TezosSignTx_TezosProposalOp

// optional bytes source = 1;
inline bool TezosSignTx_TezosProposalOp::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosProposalOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosProposalOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosProposalOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosProposalOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
}
#endif
inline void TezosSignTx_TezosProposalOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
}
inline void TezosSignTx_TezosProposalOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
}
inline ::std::string* TezosSignTx_TezosProposalOp::mutable_source() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosProposalOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosProposalOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.source)
}

// optional uint64 period = 2;
inline bool TezosSignTx_TezosProposalOp::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosProposalOp::clear_period() {
  period_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosProposalOp::period() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.period)
  return period_;
}
inline void TezosSignTx_TezosProposalOp::set_period(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  period_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.period)
}

// repeated bytes proposals = 4;
inline int TezosSignTx_TezosProposalOp::proposals_size() const {
  return proposals_.size();
}
inline void TezosSignTx_TezosProposalOp::clear_proposals() {
  proposals_.Clear();
}
inline const ::std::string& TezosSignTx_TezosProposalOp::proposals(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  return proposals_.Get(index);
}
inline ::std::string* TezosSignTx_TezosProposalOp::mutable_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  return proposals_.Mutable(index);
}
inline void TezosSignTx_TezosProposalOp::set_proposals(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  proposals_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TezosSignTx_TezosProposalOp::set_proposals(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  proposals_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TezosSignTx_TezosProposalOp::set_proposals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
inline void TezosSignTx_TezosProposalOp::set_proposals(int index, const void* value, size_t size) {
  proposals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
inline ::std::string* TezosSignTx_TezosProposalOp::add_proposals() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  return proposals_.Add();
}
inline void TezosSignTx_TezosProposalOp::add_proposals(const ::std::string& value) {
  proposals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
#if LANG_CXX11
inline void TezosSignTx_TezosProposalOp::add_proposals(::std::string&& value) {
  proposals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
#endif
inline void TezosSignTx_TezosProposalOp::add_proposals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
inline void TezosSignTx_TezosProposalOp::add_proposals(const void* value, size_t size) {
  proposals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
TezosSignTx_TezosProposalOp::proposals() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  return proposals_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
TezosSignTx_TezosProposalOp::mutable_proposals() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp.proposals)
  return &proposals_;
}

// -------------------------------------------------------------------

// TezosSignTx_TezosBallotOp

// optional bytes source = 1;
inline bool TezosSignTx_TezosBallotOp::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx_TezosBallotOp::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx_TezosBallotOp::source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
  return source_.GetNoArena();
}
inline void TezosSignTx_TezosBallotOp::set_source(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
}
#if LANG_CXX11
inline void TezosSignTx_TezosBallotOp::set_source(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
}
#endif
inline void TezosSignTx_TezosBallotOp::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
}
inline void TezosSignTx_TezosBallotOp::set_source(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
}
inline ::std::string* TezosSignTx_TezosBallotOp::mutable_source() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosBallotOp::release_source() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
  if (!has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return source_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosBallotOp::set_allocated_source(::std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.source)
}

// optional uint64 period = 2;
inline bool TezosSignTx_TezosBallotOp::has_period() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx_TezosBallotOp::clear_period() {
  period_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 TezosSignTx_TezosBallotOp::period() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.period)
  return period_;
}
inline void TezosSignTx_TezosBallotOp::set_period(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  period_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.period)
}

// optional bytes proposal = 3;
inline bool TezosSignTx_TezosBallotOp::has_proposal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx_TezosBallotOp::clear_proposal() {
  proposal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignTx_TezosBallotOp::proposal() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
  return proposal_.GetNoArena();
}
inline void TezosSignTx_TezosBallotOp::set_proposal(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  proposal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
}
#if LANG_CXX11
inline void TezosSignTx_TezosBallotOp::set_proposal(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  proposal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
}
#endif
inline void TezosSignTx_TezosBallotOp::set_proposal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  proposal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
}
inline void TezosSignTx_TezosBallotOp::set_proposal(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  proposal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
}
inline ::std::string* TezosSignTx_TezosBallotOp::mutable_proposal() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
  return proposal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx_TezosBallotOp::release_proposal() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
  if (!has_proposal()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return proposal_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx_TezosBallotOp::set_allocated_proposal(::std::string* proposal) {
  if (proposal != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  proposal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposal);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.proposal)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.TezosBallotType ballot = 4;
inline bool TezosSignTx_TezosBallotOp::has_ballot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx_TezosBallotOp::clear_ballot() {
  ballot_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType TezosSignTx_TezosBallotOp::ballot() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.ballot)
  return static_cast< ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType >(ballot_);
}
inline void TezosSignTx_TezosBallotOp::set_ballot(::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType value) {
  assert(::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ballot_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.ballot)
}

// -------------------------------------------------------------------

// TezosSignTx

// repeated uint32 address_n = 1;
inline int TezosSignTx::address_n_size() const {
  return address_n_.size();
}
inline void TezosSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TezosSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.address_n)
  return address_n_.Get(index);
}
inline void TezosSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.address_n)
}
inline void TezosSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.tezos.TezosSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TezosSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.tezos.TezosSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TezosSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.tezos.TezosSignTx.address_n)
  return &address_n_;
}

// optional bytes branch = 2;
inline bool TezosSignTx::has_branch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignTx::clear_branch() {
  branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignTx::branch() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.branch)
  return branch_.GetNoArena();
}
inline void TezosSignTx::set_branch(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignTx.branch)
}
#if LANG_CXX11
inline void TezosSignTx::set_branch(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  branch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignTx.branch)
}
#endif
inline void TezosSignTx::set_branch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignTx.branch)
}
inline void TezosSignTx::set_branch(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignTx.branch)
}
inline ::std::string* TezosSignTx::mutable_branch() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.branch)
  return branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignTx::release_branch() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.branch)
  if (!has_branch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return branch_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignTx::set_allocated_branch(::std::string* branch) {
  if (branch != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), branch);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.branch)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp reveal = 3;
inline bool TezosSignTx::has_reveal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignTx::clear_reveal() {
  if (reveal_ != nullptr) reveal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp& TezosSignTx::reveal() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* p = reveal_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.reveal)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosRevealOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* TezosSignTx::release_reveal() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.reveal)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* temp = reveal_;
  reveal_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* TezosSignTx::mutable_reveal() {
  _has_bits_[0] |= 0x00000002u;
  if (reveal_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp>(GetArenaNoVirtual());
    reveal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.reveal)
  return reveal_;
}
inline void TezosSignTx::set_allocated_reveal(::hw::trezor::messages::tezos::TezosSignTx_TezosRevealOp* reveal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reveal_;
  }
  if (reveal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reveal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reveal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reveal_ = reveal;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.reveal)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp transaction = 4;
inline bool TezosSignTx::has_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignTx::clear_transaction() {
  if (transaction_ != nullptr) transaction_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp& TezosSignTx::transaction() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* p = transaction_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.transaction)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosTransactionOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* TezosSignTx::release_transaction() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.transaction)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* TezosSignTx::mutable_transaction() {
  _has_bits_[0] |= 0x00000004u;
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.transaction)
  return transaction_;
}
inline void TezosSignTx::set_allocated_transaction(::hw::trezor::messages::tezos::TezosSignTx_TezosTransactionOp* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.transaction)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp origination = 5;
inline bool TezosSignTx::has_origination() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TezosSignTx::clear_origination() {
  if (origination_ != nullptr) origination_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp& TezosSignTx::origination() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* p = origination_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.origination)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosOriginationOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* TezosSignTx::release_origination() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.origination)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* temp = origination_;
  origination_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* TezosSignTx::mutable_origination() {
  _has_bits_[0] |= 0x00000008u;
  if (origination_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp>(GetArenaNoVirtual());
    origination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.origination)
  return origination_;
}
inline void TezosSignTx::set_allocated_origination(::hw::trezor::messages::tezos::TezosSignTx_TezosOriginationOp* origination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete origination_;
  }
  if (origination) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      origination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origination, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  origination_ = origination;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.origination)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp delegation = 6;
inline bool TezosSignTx::has_delegation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TezosSignTx::clear_delegation() {
  if (delegation_ != nullptr) delegation_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp& TezosSignTx::delegation() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* p = delegation_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.delegation)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosDelegationOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* TezosSignTx::release_delegation() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.delegation)
  _has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* temp = delegation_;
  delegation_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* TezosSignTx::mutable_delegation() {
  _has_bits_[0] |= 0x00000010u;
  if (delegation_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp>(GetArenaNoVirtual());
    delegation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.delegation)
  return delegation_;
}
inline void TezosSignTx::set_allocated_delegation(::hw::trezor::messages::tezos::TezosSignTx_TezosDelegationOp* delegation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete delegation_;
  }
  if (delegation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delegation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delegation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  delegation_ = delegation;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.delegation)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp proposal = 7;
inline bool TezosSignTx::has_proposal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TezosSignTx::clear_proposal() {
  if (proposal_ != nullptr) proposal_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp& TezosSignTx::proposal() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* p = proposal_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.proposal)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosProposalOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* TezosSignTx::release_proposal() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.proposal)
  _has_bits_[0] &= ~0x00000020u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* TezosSignTx::mutable_proposal() {
  _has_bits_[0] |= 0x00000020u;
  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp>(GetArenaNoVirtual());
    proposal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.proposal)
  return proposal_;
}
inline void TezosSignTx::set_allocated_proposal(::hw::trezor::messages::tezos::TezosSignTx_TezosProposalOp* proposal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete proposal_;
  }
  if (proposal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proposal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.proposal)
}

// optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp ballot = 8;
inline bool TezosSignTx::has_ballot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TezosSignTx::clear_ballot() {
  if (ballot_ != nullptr) ballot_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp& TezosSignTx::ballot() const {
  const ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* p = ballot_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignTx.ballot)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp*>(
      &::hw::trezor::messages::tezos::_TezosSignTx_TezosBallotOp_default_instance_);
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* TezosSignTx::release_ballot() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignTx.ballot)
  _has_bits_[0] &= ~0x00000040u;
  ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* temp = ballot_;
  ballot_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* TezosSignTx::mutable_ballot() {
  _has_bits_[0] |= 0x00000040u;
  if (ballot_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp>(GetArenaNoVirtual());
    ballot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignTx.ballot)
  return ballot_;
}
inline void TezosSignTx::set_allocated_ballot(::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp* ballot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ballot_;
  }
  if (ballot) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ballot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ballot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  ballot_ = ballot;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignTx.ballot)
}

// -------------------------------------------------------------------

// TezosSignedTx

// optional string signature = 1;
inline bool TezosSignedTx::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TezosSignedTx::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TezosSignedTx::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignedTx.signature)
  return signature_.GetNoArena();
}
inline void TezosSignedTx::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignedTx.signature)
}
#if LANG_CXX11
inline void TezosSignedTx::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignedTx.signature)
}
#endif
inline void TezosSignedTx::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignedTx.signature)
}
inline void TezosSignedTx::set_signature(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignedTx.signature)
}
inline ::std::string* TezosSignedTx::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignedTx.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignedTx::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignedTx.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignedTx::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignedTx.signature)
}

// optional bytes sig_op_contents = 2;
inline bool TezosSignedTx::has_sig_op_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TezosSignedTx::clear_sig_op_contents() {
  sig_op_contents_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TezosSignedTx::sig_op_contents() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
  return sig_op_contents_.GetNoArena();
}
inline void TezosSignedTx::set_sig_op_contents(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sig_op_contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
}
#if LANG_CXX11
inline void TezosSignedTx::set_sig_op_contents(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sig_op_contents_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
}
#endif
inline void TezosSignedTx::set_sig_op_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sig_op_contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
}
inline void TezosSignedTx::set_sig_op_contents(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sig_op_contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
}
inline ::std::string* TezosSignedTx::mutable_sig_op_contents() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
  return sig_op_contents_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignedTx::release_sig_op_contents() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
  if (!has_sig_op_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sig_op_contents_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignedTx::set_allocated_sig_op_contents(::std::string* sig_op_contents) {
  if (sig_op_contents != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sig_op_contents_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig_op_contents);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignedTx.sig_op_contents)
}

// optional string operation_hash = 3;
inline bool TezosSignedTx::has_operation_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TezosSignedTx::clear_operation_hash() {
  operation_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TezosSignedTx::operation_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
  return operation_hash_.GetNoArena();
}
inline void TezosSignedTx::set_operation_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  operation_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
}
#if LANG_CXX11
inline void TezosSignedTx::set_operation_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  operation_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
}
#endif
inline void TezosSignedTx::set_operation_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  operation_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
}
inline void TezosSignedTx::set_operation_hash(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  operation_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
}
inline ::std::string* TezosSignedTx::mutable_operation_hash() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
  return operation_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TezosSignedTx::release_operation_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
  if (!has_operation_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return operation_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TezosSignedTx::set_allocated_operation_hash(::std::string* operation_hash) {
  if (operation_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  operation_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.tezos.TezosSignedTx.operation_hash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tezos
}  // namespace messages
}  // namespace trezor
}  // namespace hw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType>() {
  return ::hw::trezor::messages::tezos::TezosSignTx_TezosContractID_TezosContractType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType>() {
  return ::hw::trezor::messages::tezos::TezosSignTx_TezosBallotOp_TezosBallotType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dtezos_2eproto
